<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Portfolio Analyst</title>
<script src="https://wealthica.github.io/wealthica.js/dist/addon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-primary: #0a0e17;
    --bg-secondary: #111827;
    --bg-card: #1a2234;
    --bg-card-hover: #1f2a3f;
    --border: #2a3550;
    --border-accent: #3b82f6;
    --text-primary: #f1f5f9;
    --text-secondary: #94a3b8;
    --text-muted: #64748b;
    --accent: #3b82f6;
    --accent-glow: rgba(59, 130, 246, 0.15);
    --green: #22c55e;
    --green-bg: rgba(34, 197, 94, 0.1);
    --red: #ef4444;
    --red-bg: rgba(239, 68, 68, 0.1);
    --yellow: #f59e0b;
    --yellow-bg: rgba(245, 158, 11, 0.1);
    --purple: #a855f7;
    --purple-bg: rgba(168, 85, 247, 0.1);
    --cyan: #06b6d4;
    --pink: #ec4899;
    --orange: #f97316;
    --teal: #14b8a6;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; width: 100%; }
  body {
    font-family: 'DM Sans', sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    line-height: 1.6;
    min-height: 100vh;
    overflow-x: hidden;
  }
  body::before {
    content: '';
    position: fixed;
    top: -200px; right: -200px;
    width: 600px; height: 600px;
    background: radial-gradient(circle, rgba(59,130,246,0.06) 0%, transparent 70%);
    pointer-events: none; z-index: 0;
  }
  .container { max-width: 1100px; margin: 0 auto; padding: 24px 20px; position: relative; z-index: 1; }

  /* Header */
  .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
  .header-left { display: flex; align-items: center; gap: 14px; }
  .logo-mark { width: 40px; height: 40px; border-radius: 10px; background: linear-gradient(135deg, var(--accent), #7c3aed); display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 700; color: white; box-shadow: 0 4px 16px rgba(59,130,246,0.25); }
  .header h1 { font-size: 20px; font-weight: 600; letter-spacing: -0.3px; }
  .header h1 span { color: var(--accent); }
  .header-right { display: flex; align-items: center; gap: 10px; }
  .btn-settings { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-secondary); padding: 8px 14px; border-radius: 8px; cursor: pointer; font-family: inherit; font-size: 13px; display: flex; align-items: center; gap: 6px; transition: all 0.2s; }
  .btn-settings:hover { border-color: var(--accent); color: var(--text-primary); background: var(--bg-card-hover); }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-muted); transition: background 0.3s; }
  .status-dot.connected { background: var(--green); box-shadow: 0 0 8px rgba(34,197,94,0.4); }
  .status-dot.error { background: var(--red); }

  /* Settings Panel */
  .settings-panel { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-bottom: 16px; display: none; animation: slideDown 0.2s ease-out; }
  .settings-panel.visible { display: block; }
  @keyframes slideDown { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }
  .settings-panel label { display: block; font-size: 12px; font-weight: 500; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
  .settings-panel .input-row { display: flex; gap: 10px; }
  .settings-panel input { flex: 1; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); padding: 10px 14px; border-radius: 8px; font-family: 'JetBrains Mono', monospace; font-size: 13px; outline: none; transition: border-color 0.2s; }
  .settings-panel input:focus { border-color: var(--accent); }
  .settings-panel .hint { font-size: 12px; color: var(--text-muted); margin-top: 8px; line-height: 1.5; }
  .settings-panel .hint a { color: var(--accent); text-decoration: none; }

  /* Tab Navigation */
  .tab-nav { display: flex; gap: 2px; margin-bottom: 20px; border-bottom: 1px solid var(--border); overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
  .tab-nav::-webkit-scrollbar { display: none; }
  .tab-btn { padding: 10px 18px; background: none; border: none; border-bottom: 2px solid transparent; color: var(--text-muted); font-family: inherit; font-size: 13px; font-weight: 500; cursor: pointer; white-space: nowrap; transition: all 0.2s; }
  .tab-btn:hover { color: var(--text-primary); }
  .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }

  /* Filter Bar */
  .filter-bar { display: flex; align-items: center; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; }
  .filter-bar label { font-size: 12px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
  .filter-bar select { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-primary); padding: 6px 12px; border-radius: 6px; font-family: inherit; font-size: 12px; cursor: pointer; outline: none; }
  .filter-bar select:focus { border-color: var(--accent); }

  /* Risk Slider */
  .risk-slider-wrap { display: flex; align-items: center; gap: 12px; margin-left: auto; }
  .risk-slider-wrap label { font-size: 12px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; white-space: nowrap; }
  .risk-slider { -webkit-appearance: none; appearance: none; width: 120px; height: 6px; border-radius: 3px; background: linear-gradient(90deg, var(--green), var(--yellow), var(--red)); outline: none; cursor: pointer; }
  .risk-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: white; border: 2px solid var(--accent); cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
  .risk-slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: white; border: 2px solid var(--accent); cursor: pointer; }
  .risk-level-label { font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 600; min-width: 90px; }

  /* Buttons */
  .btn-primary { background: var(--accent); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-family: inherit; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
  .btn-primary:hover { background: #2563eb; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(59,130,246,0.3); }
  .btn-primary:active { transform: translateY(0); }
  .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
  .btn-accent { background: linear-gradient(135deg, var(--accent), var(--purple)); color: white; border: none; padding: 8px 16px; border-radius: 8px; font-family: inherit; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px; }
  .btn-accent:hover { transform: translateY(-1px); box-shadow: 0 4px 16px rgba(59,130,246,0.3); }
  .btn-accent:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

  /* Tab Panels */
  .tab-panel { display: none; animation: fadeIn 0.3s ease; }
  .tab-panel.active { display: block; }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  /* Summary Cards */
  .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 20px; }
  .summary-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px; padding: 16px; transition: border-color 0.2s; }
  .summary-card:hover { border-color: var(--border-accent); }
  .summary-card .label { font-size: 11px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin-bottom: 6px; }
  .summary-card .value { font-size: 20px; font-weight: 700; letter-spacing: -0.5px; font-family: 'JetBrains Mono', monospace; }
  .summary-card .sub { font-size: 12px; color: var(--text-secondary); margin-top: 4px; }
  .positive { color: var(--green); }
  .negative { color: var(--red); }

  /* Score Banner */
  .score-banner { display: flex; align-items: center; gap: 24px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin-bottom: 20px; }
  .score-ring { position: relative; width: 100px; height: 100px; flex-shrink: 0; }
  .score-ring .ring-bg { fill: none; stroke: var(--border); stroke-width: 8; }
  .score-ring .ring-fill { fill: none; stroke-width: 8; stroke-linecap: round; transition: stroke-dashoffset 1s ease, stroke 0.5s; }
  .score-ring .score-text { font-family: 'JetBrains Mono', monospace; font-size: 24px; font-weight: 700; fill: var(--text-primary); text-anchor: middle; dominant-baseline: central; }
  .score-details h2 { font-size: 16px; font-weight: 600; margin-bottom: 4px; }
  .score-details p { font-size: 13px; color: var(--text-secondary); line-height: 1.5; }

  /* Chart Cards */
  .charts-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px; }
  .chart-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
  .chart-card h3 { font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin-bottom: 16px; font-weight: 500; }
  .chart-card canvas { max-height: 280px; }

  /* Accounts Grid */
  .accounts-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; margin-bottom: 20px; }
  .account-chip { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 10px 14px; font-size: 12px; }
  .account-chip .acct-name { font-weight: 500; color: var(--text-primary); margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .account-chip .acct-value { font-family: 'JetBrains Mono', monospace; font-size: 14px; font-weight: 600; color: var(--accent); }

  /* Holdings Controls */
  .holdings-controls { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; flex-wrap: wrap; gap: 10px; }
  .holdings-controls select { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-primary); padding: 8px 12px; border-radius: 8px; font-family: inherit; font-size: 13px; cursor: pointer; outline: none; }

  /* Holdings Grid */
  .holdings-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 12px; }
  .position-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px; padding: 16px; transition: all 0.2s; }
  .position-card:hover { border-color: var(--accent); transform: translateY(-1px); box-shadow: 0 4px 16px rgba(59,130,246,0.1); }
  .pos-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
  .pos-symbol { font-family: 'JetBrains Mono', monospace; font-weight: 600; font-size: 15px; }
  .pos-name { font-size: 11px; color: var(--text-muted); margin-top: 1px; }
  .pos-account { font-size: 10px; color: var(--text-muted); background: var(--bg-primary); padding: 2px 6px; border-radius: 4px; margin-top: 4px; display: inline-block; }
  .pos-values { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
  .pos-metric .pm-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.3px; }
  .pos-metric .pm-value { font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 500; }
  .pos-weight-bar { height: 4px; background: var(--bg-primary); border-radius: 2px; margin-top: 10px; overflow: hidden; }
  .pos-weight-fill { height: 100%; border-radius: 2px; transition: width 0.5s ease; background: var(--accent); }
  .pos-weight-label { font-size: 10px; color: var(--text-muted); margin-top: 4px; }

  /* Rating Badge */
  .rating-badge { width: 38px; height: 38px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 14px; flex-shrink: 0; }
  .rating-badge.excellent { background: var(--green-bg); color: var(--green); }
  .rating-badge.good { background: rgba(59,130,246,0.15); color: var(--accent); }
  .rating-badge.fair { background: var(--yellow-bg); color: var(--yellow); }
  .rating-badge.poor { background: var(--red-bg); color: var(--red); }
  .rec-chip { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; margin-top: 6px; }
  .rec-chip.strong-buy, .rec-chip.buy { background: var(--green-bg); color: var(--green); }
  .rec-chip.hold { background: rgba(59,130,246,0.15); color: var(--accent); }
  .rec-chip.trim { background: var(--yellow-bg); color: var(--yellow); }
  .rec-chip.sell { background: var(--red-bg); color: var(--red); }
  .pos-reasoning { font-size: 11px; color: var(--text-secondary); margin-top: 6px; line-height: 1.4; font-style: italic; }

  /* Score Cards */
  .score-cards-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 20px; }
  .score-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; text-align: center; }
  .score-card .sc-value { font-family: 'JetBrains Mono', monospace; font-size: 32px; font-weight: 700; margin-bottom: 4px; }
  .score-card .sc-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
  .score-card .sc-bar { height: 4px; background: var(--bg-primary); border-radius: 2px; margin-top: 10px; overflow: hidden; }
  .score-card .sc-bar-fill { height: 100%; border-radius: 2px; transition: width 0.8s ease; }

  /* Score Breakdown Section */
  .score-breakdown { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; margin-bottom: 20px; }
  .score-breakdown-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 18px; transition: border-color 0.2s; }
  .score-breakdown-card:hover { border-color: var(--border-accent); }
  .score-breakdown-card .sbc-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
  .score-breakdown-card .sbc-label { font-size: 13px; font-weight: 600; color: var(--text-primary); }
  .score-breakdown-card .sbc-weight { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
  .score-breakdown-card .sbc-score { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
  .score-breakdown-card .sbc-value { font-family: 'JetBrains Mono', monospace; font-size: 28px; font-weight: 700; min-width: 48px; }
  .score-breakdown-card .sbc-bar-wrap { flex: 1; }
  .score-breakdown-card .sbc-bar { height: 8px; background: var(--bg-primary); border-radius: 4px; overflow: hidden; }
  .score-breakdown-card .sbc-bar-fill { height: 100%; border-radius: 4px; transition: width 0.8s ease; }
  .score-breakdown-card .sbc-grade { font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 600; padding: 2px 8px; border-radius: 4px; }
  .score-breakdown-card .sbc-desc { font-size: 12px; color: var(--text-secondary); line-height: 1.5; }

  /* Insights Panel */
  .insights-panel { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; margin-bottom: 20px; }
  .insights-panel h3 { font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin-bottom: 14px; font-weight: 500; }
  .insight-item { display: flex; align-items: flex-start; gap: 10px; padding: 8px 0; border-bottom: 1px solid rgba(42,53,80,0.3); }
  .insight-item:last-child { border-bottom: none; }
  .insight-dot { width: 8px; height: 8px; border-radius: 50%; margin-top: 6px; flex-shrink: 0; }
  .insight-text { font-size: 13px; color: var(--text-secondary); line-height: 1.5; }
  .insight-text strong { color: var(--text-primary); }

  /* Risk Factors */
  .risk-factors { display: grid; gap: 10px; margin-top: 20px; }
  .risk-factor { background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px; padding: 14px 18px; display: flex; align-items: center; gap: 12px; }
  .risk-factor .severity { width: 4px; height: 36px; border-radius: 2px; flex-shrink: 0; }
  .risk-factor .severity.high { background: var(--red); }
  .risk-factor .severity.medium { background: var(--yellow); }
  .risk-factor .severity.low { background: var(--green); }
  .risk-factor .rf-title { font-size: 13px; font-weight: 500; }
  .risk-factor .rf-desc { font-size: 12px; color: var(--text-muted); margin-top: 2px; }

  /* Region Cards */
  .region-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px; margin-top: 20px; }
  .region-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px; padding: 16px; }
  .region-card .rc-name { font-weight: 600; font-size: 14px; margin-bottom: 4px; }
  .region-card .rc-pct { font-family: 'JetBrains Mono', monospace; font-size: 24px; font-weight: 700; color: var(--accent); }
  .region-card .rc-value { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
  .region-card .rc-bar { height: 4px; background: var(--bg-primary); border-radius: 2px; margin-top: 10px; overflow: hidden; }
  .region-card .rc-bar-fill { height: 100%; border-radius: 2px; }

  /* Actions Cards (Small/Big Moves) */
  .actions-section { margin-top: 20px; }
  .actions-section h3 { font-size: 14px; font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
  .action-cards { display: grid; gap: 10px; }
  .action-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px; padding: 14px 18px; display: flex; align-items: flex-start; gap: 12px; }
  .action-card .action-icon { width: 32px; height: 32px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; font-weight: 700; }
  .action-card .action-icon.small { background: var(--green-bg); color: var(--green); }
  .action-card .action-icon.big { background: var(--purple-bg); color: var(--purple); }
  .action-card .action-title { font-size: 13px; font-weight: 500; }
  .action-card .action-desc { font-size: 12px; color: var(--text-muted); margin-top: 2px; line-height: 1.4; }
  .action-card .action-impact { font-size: 11px; font-weight: 600; margin-top: 4px; }

  /* AI Section */
  .analysis-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; flex-wrap: wrap; gap: 10px; }
  .analysis-header h2 { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
  .analysis-actions { display: flex; gap: 8px; flex-wrap: wrap; }
  .prompt-select { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-primary); padding: 8px 12px; border-radius: 8px; font-family: inherit; font-size: 13px; cursor: pointer; outline: none; }
  .prompt-select:focus { border-color: var(--accent); }
  .custom-prompt-area { display: none; margin-top: 12px; margin-bottom: 16px; }
  .custom-prompt-area.visible { display: block; }
  .custom-prompt-area textarea { width: 100%; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); padding: 12px 14px; border-radius: 8px; font-family: inherit; font-size: 13px; line-height: 1.6; resize: vertical; min-height: 80px; outline: none; }
  .custom-prompt-area textarea:focus { border-color: var(--accent); }

  .ai-response { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 24px; min-height: 200px; position: relative; overflow: hidden; max-height: 600px; overflow-y: auto; }
  .ai-response::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, var(--accent), var(--purple), var(--accent)); background-size: 200% 100%; opacity: 0; transition: opacity 0.3s; }
  .ai-response.loading::before { opacity: 1; animation: shimmer 2s linear infinite; }
  @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
  .ai-response .placeholder { color: var(--text-muted); text-align: center; padding: 60px 20px; font-size: 14px; }
  .ai-response::-webkit-scrollbar { width: 6px; }
  .ai-response::-webkit-scrollbar-track { background: transparent; }
  .ai-response::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* AI Content (improved readability) */
  .ai-content { font-size: 14px; line-height: 1.8; color: var(--text-secondary); }
  .ai-content h1, .ai-content h2, .ai-content h3 { color: var(--text-primary); margin-top: 20px; margin-bottom: 10px; font-weight: 600; }
  .ai-content h1 { font-size: 18px; }
  .ai-content h2 { font-size: 16px; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 6px; }
  .ai-content h3 { font-size: 14px; color: var(--text-secondary); }
  .ai-content p { margin-bottom: 12px; color: var(--text-secondary); }
  .ai-content strong { color: var(--text-primary); font-weight: 600; }
  .ai-content em { color: var(--text-muted); }
  .ai-content ul, .ai-content ol { margin: 8px 0 16px 20px; }
  .ai-content ol { list-style: decimal; }
  .ai-content li { margin-bottom: 6px; padding-left: 4px; }
  .ai-content li::marker { color: var(--accent); }
  .ai-content code { background: var(--bg-primary); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--purple); }
  .ai-content hr { border: none; border-top: 1px solid var(--border); margin: 20px 0; }
  .streaming-cursor::after { content: '\25CA'; color: var(--accent); animation: blink 0.8s step-end infinite; }
  @keyframes blink { 50% { opacity: 0; } }

  /* Spinner */
  .spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.2); border-top-color: white; border-radius: 50%; animation: spin 0.7s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Toast */
  .toast { position: fixed; bottom: 20px; right: 20px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px; padding: 12px 18px; font-size: 13px; color: var(--text-primary); box-shadow: 0 8px 32px rgba(0,0,0,0.3); transform: translateY(100px); opacity: 0; transition: all 0.3s ease; z-index: 100; }
  .toast.visible { transform: translateY(0); opacity: 1; }
  .toast.error { border-color: var(--red); }
  .toast.success { border-color: var(--green); }

  /* Responsive */
  @media (max-width: 768px) {
    .charts-row { grid-template-columns: 1fr; }
    .holdings-grid { grid-template-columns: 1fr; }
    .score-banner { flex-direction: column; text-align: center; }
    .header { flex-direction: column; align-items: flex-start; gap: 12px; }
    .analysis-header { flex-direction: column; align-items: flex-start; }
    .filter-bar { flex-direction: column; align-items: flex-start; }
    .risk-slider-wrap { margin-left: 0; }
    .holdings-controls { flex-direction: column; }
  }
  @media (max-width: 480px) {
    .summary-grid { grid-template-columns: 1fr 1fr; }
    .score-cards-grid { grid-template-columns: 1fr 1fr; }
    .tab-btn { padding: 8px 12px; font-size: 12px; }
  }
</style>
</head>
<body>
<div class="container">
  <!-- Header -->
  <div class="header">
    <div class="header-left">
      <div class="logo-mark">AI</div>
      <h1>Portfolio <span>Analyst</span></h1>
    </div>
    <div class="header-right">
      <div class="status-dot" id="statusDot" title="Not connected"></div>
      <button class="btn-settings" id="btnSettings" onclick="toggleSettings()">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
        API Key
      </button>
    </div>
  </div>

  <!-- Settings Panel -->
  <div class="settings-panel" id="settingsPanel">
    <label>Anthropic API Key</label>
    <div class="input-row">
      <input type="password" id="apiKeyInput" placeholder="sk-ant-api03-..." autocomplete="off" />
      <button class="btn-primary" onclick="saveApiKey()">Save</button>
    </div>
    <div class="hint">
      Your key is stored in Wealthica's add-on data (tied to your account). Get a key from
      <a href="https://console.anthropic.com/settings/keys" target="_blank">console.anthropic.com</a>.
      <br>API calls are billed to your Anthropic account. Each analysis uses ~2-3K tokens.
    </div>
  </div>

  <!-- Tab Navigation -->
  <nav class="tab-nav" id="tabNav">
    <button class="tab-btn active" onclick="switchTab('overview')">Overview</button>
    <button class="tab-btn" onclick="switchTab('holdings')">Holdings</button>
    <button class="tab-btn" onclick="switchTab('sectors')">Sectors</button>
    <button class="tab-btn" onclick="switchTab('performance')">Performance</button>
    <button class="tab-btn" onclick="switchTab('risk')">Risk</button>
    <button class="tab-btn" onclick="switchTab('region')">Region</button>
    <button class="tab-btn" onclick="switchTab('dividends')">Dividends</button>
    <button class="tab-btn" onclick="switchTab('tax')">Tax</button>
    <button class="tab-btn" onclick="switchTab('ai')">AI Analyst</button>
  </nav>

  <!-- Filter Bar -->
  <div class="filter-bar" id="filterBar">
    <label>Account</label>
    <select id="accountFilter" onchange="applyAccountFilter()">
      <option value="all">All Accounts</option>
    </select>
    <div class="risk-slider-wrap">
      <label>Risk Tolerance</label>
      <input type="range" class="risk-slider" id="riskSlider" min="1" max="10" value="5" oninput="onRiskChange()">
      <span class="risk-level-label" id="riskLabel" style="color:var(--yellow)">Moderate</span>
    </div>
  </div>

  <!-- ==================== OVERVIEW TAB ==================== -->
  <section class="tab-panel active" id="panel-overview">
    <div class="score-banner" id="scoreBanner">
      <div class="score-ring">
        <svg width="100" height="100" viewBox="0 0 100 100">
          <circle class="ring-bg" cx="50" cy="50" r="42"/>
          <circle class="ring-fill" id="healthRingFill" cx="50" cy="50" r="42" stroke="var(--accent)" stroke-dasharray="263.89" stroke-dashoffset="263.89" transform="rotate(-90 50 50)"/>
          <text class="score-text" id="healthScoreText" x="50" y="50">--</text>
        </svg>
      </div>
      <div class="score-details" style="flex:1">
        <h2>Portfolio Health Score</h2>
        <p id="healthSummary">Load your portfolio to see your health score and actionable insights.</p>
        <div class="sub-scores" id="subScores" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:8px;margin-top:12px;"></div>
      </div>
    </div>

    <div class="summary-grid" id="summaryGrid">
      <div class="summary-card"><div class="label">Total Value</div><div class="value" id="totalValue">--</div><div class="sub" id="totalAccounts"></div></div>
      <div class="summary-card"><div class="label">Positions</div><div class="value" id="totalPositions">--</div><div class="sub" id="positionsSub"></div></div>
      <div class="summary-card"><div class="label">Total Gain/Loss</div><div class="value" id="totalGainLoss">--</div><div class="sub" id="gainLossPct"></div></div>
      <div class="summary-card"><div class="label">Top Holding</div><div class="value" id="topHolding" style="font-size:16px">--</div><div class="sub" id="topHoldingPct"></div></div>
    </div>

    <!-- Score Breakdown Cards -->
    <div class="score-breakdown" id="scoreBreakdown"></div>

    <!-- Key Insights -->
    <div class="insights-panel" id="insightsPanel" style="display:none">
      <h3>Key Insights</h3>
      <div id="insightsList"></div>
    </div>

    <div class="charts-row">
      <div class="chart-card"><h3>Asset Allocation</h3><canvas id="allocationChart"></canvas></div>
      <div class="chart-card"><h3>Top Holdings</h3><canvas id="topHoldingsChart"></canvas></div>
    </div>

    <div class="accounts-grid" id="accountsGrid"></div>

    <!-- Small & Big Moves -->
    <div class="actions-section" id="smallMovesSection" style="display:none">
      <h3><span style="color:var(--green)">Quick Wins</span> — Small changes, meaningful impact</h3>
      <div class="action-cards" id="smallMoves"></div>
    </div>
    <div class="actions-section" id="bigMovesSection" style="display:none; margin-top:24px">
      <h3><span style="color:var(--purple)">Strategic Moves</span> — Bigger changes for long-term improvement</h3>
      <div class="action-cards" id="bigMoves"></div>
    </div>
  </section>

  <!-- ==================== HOLDINGS TAB ==================== -->
  <section class="tab-panel" id="panel-holdings">
    <div class="holdings-controls">
      <select id="holdingsSort" onchange="renderHoldingsTab()">
        <option value="value">Sort by Value</option>
        <option value="gainloss">Sort by Gain/Loss</option>
        <option value="return">Sort by Return %</option>
        <option value="weight">Sort by Weight</option>
        <option value="name">Sort by Name</option>
        <option value="rating">Sort by AI Rating</option>
      </select>
      <button class="btn-accent" id="btnRatePositions" onclick="ratePositions()">
        Get AI Position Ratings
      </button>
    </div>
    <div class="holdings-grid" id="holdingsGrid"></div>
    <div class="chart-card" style="margin-top:20px"><h3>Portfolio Weights</h3><canvas id="holdingsWeightChart"></canvas></div>
  </section>

  <!-- ==================== PERFORMANCE TAB ==================== -->
  <section class="tab-panel" id="panel-performance">
    <div class="summary-grid" id="perfSummaryGrid"></div>
    <div class="chart-card"><h3>Gain/Loss by Position</h3><canvas id="gainLossChart"></canvas></div>
    <div class="chart-card" style="margin-top:20px"><h3>Performance by Account</h3><canvas id="accountPerfChart"></canvas></div>
  </section>

  <!-- ==================== RISK TAB ==================== -->
  <section class="tab-panel" id="panel-risk">
    <div class="score-cards-grid" id="riskScoresGrid"></div>
    <div class="charts-row">
      <div class="chart-card"><h3>Concentration</h3><canvas id="concentrationChart"></canvas></div>
      <div class="chart-card"><h3>Position Weight Distribution</h3><canvas id="riskWeightsChart"></canvas></div>
    </div>
    <div class="risk-factors" id="riskFactors"></div>
  </section>

  <!-- ==================== REGION TAB ==================== -->
  <section class="tab-panel" id="panel-region">
    <div class="charts-row">
      <div class="chart-card"><h3>Geographic Allocation</h3><canvas id="geoChart"></canvas></div>
      <div class="chart-card"><h3>Currency Exposure</h3><canvas id="currencyChart"></canvas></div>
    </div>
    <div class="region-cards" id="regionCards"></div>
  </section>

  <!-- ==================== SECTORS TAB ==================== -->
  <section class="tab-panel" id="panel-sectors">
    <div class="charts-row">
      <div class="chart-card"><h3>Sector Allocation</h3><canvas id="sectorDetailChart"></canvas></div>
      <div class="chart-card"><h3>Sector Values</h3><canvas id="sectorBarChart"></canvas></div>
    </div>
    <div class="holdings-grid" id="sectorCards"></div>
  </section>

  <!-- ==================== DIVIDENDS TAB ==================== -->
  <section class="tab-panel" id="panel-dividends">
    <div class="summary-grid" id="divSummaryGrid"></div>
    <div class="charts-row">
      <div class="chart-card"><h3>Income-Generating Holdings</h3><canvas id="incomeChart"></canvas></div>
      <div class="chart-card"><h3>Income by Account Type</h3><canvas id="incomeAccountChart"></canvas></div>
    </div>
    <div class="holdings-grid" id="incomeHoldingsGrid"></div>
  </section>

  <!-- ==================== TAX TAB ==================== -->
  <section class="tab-panel" id="panel-tax">
    <div class="score-banner" id="taxBanner">
      <div class="score-ring">
        <svg width="100" height="100" viewBox="0 0 100 100">
          <circle class="ring-bg" cx="50" cy="50" r="42"/>
          <circle class="ring-fill" id="taxRingFill" cx="50" cy="50" r="42" stroke="var(--accent)" stroke-dasharray="263.89" stroke-dashoffset="263.89" transform="rotate(-90 50 50)"/>
          <text class="score-text" id="taxScoreText" x="50" y="50">--</text>
        </svg>
      </div>
      <div class="score-details">
        <h2>Tax Efficiency Score</h2>
        <p id="taxSummary">Load your portfolio to see tax optimization opportunities.</p>
      </div>
    </div>
    <div class="summary-grid" id="taxSummaryGrid"></div>
    <div class="chart-card"><h3>Unrealized Gains/Losses by Account Type</h3><canvas id="taxGLChart"></canvas></div>
    <div class="risk-factors" id="taxIssues" style="margin-top:16px"></div>
  </section>

  <!-- ==================== AI ANALYST TAB ==================== -->
  <section class="tab-panel" id="panel-ai">
    <div class="analysis-header">
      <h2>
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
        AI Analysis
      </h2>
      <div class="analysis-actions">
        <select class="prompt-select" id="promptSelect" onchange="onPromptChange()">
          <option value="full">Full Analysis</option>
          <option value="risk">Concentration &amp; Risk</option>
          <option value="tax">Tax Optimization (Canadian)</option>
          <option value="rebalance">Rebalancing Suggestions</option>
          <option value="income">Income &amp; Dividends</option>
          <option value="custom">Custom Question...</option>
        </select>
        <button class="btn-primary" id="btnAnalyze" onclick="runAnalysis()" disabled>
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polygon points="5 3 19 12 5 21 5 3"/></svg>
          Analyze
        </button>
      </div>
    </div>
    <div class="custom-prompt-area" id="customPromptArea">
      <textarea id="customPrompt" placeholder="Ask anything about your portfolio... e.g. 'What is my exposure to US tech stocks?' or 'How should I rebalance for retirement in 20 years?'"></textarea>
    </div>
    <div class="ai-response" id="aiResponse">
      <div class="placeholder">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="12" cy="12" r="10"/><path d="M8 12h8M12 8v8"/></svg>
        <br>Load your portfolio data, then click <strong>Analyze</strong> to get AI-powered insights.
      </div>
    </div>
  </section>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ─── State ───────────────────────────────────────────────────────────────────
let addon = null;
let apiKey = '';
let portfolioData = { positions: [], institutions: [], totalValue: 0, totalBook: 0 };
let filteredPositions = [];
let currentOptions = {};
let positionRatings = {};
let riskTolerance = 5;
let activeTab = 'overview';
const charts = {};

const CHART_COLORS = ['#3b82f6','#a855f7','#22c55e','#f59e0b','#ef4444','#06b6d4','#ec4899','#f97316','#14b8a6','#6366f1','#84cc16','#f43f5e'];

// ─── Prompt Templates ────────────────────────────────────────────────────────
const PROMPTS = {
  full: `You are a senior portfolio analyst. Analyze this Canadian investor's portfolio and provide:\n\n1. **Portfolio Overview** — Total value, number of positions, asset class breakdown\n2. **Concentration Risk** — Any single positions >10% of portfolio, sector concentration\n3. **Geographic Exposure** — Canadian vs US vs International allocation\n4. **Account Type Optimization** — Are holdings in the right account types (RRSP/TFSA/Non-reg) for tax efficiency?\n5. **Key Risks** — What are the top 3 risks in this portfolio?\n6. **Suggestions** — 3-5 actionable rebalancing suggestions\n\nUse CAD as the default currency. Be specific with numbers and percentages. Format with markdown headers and bullet points.`,
  risk: `You are a risk analyst. Analyze this portfolio for concentration and risk:\n\n1. **Single Stock Concentration** — Flag any position >5% of total portfolio\n2. **Sector Exposure** — Identify sector tilts vs broad market\n3. **Correlation Risk** — Which holdings are likely highly correlated?\n4. **Downside Scenarios** — What happens if the top 3 holdings drop 30%?\n5. **Diversification Score** — Rate the portfolio's diversification 1-10\n\nBe specific with dollar amounts and percentages. Use CAD.`,
  tax: `You are a Canadian tax optimization specialist. Analyze this portfolio for tax efficiency:\n\n1. **Account Placement** — Are US dividend payers in RRSP (withholding tax advantage)? Are growth stocks in TFSA?\n2. **Tax-Loss Harvesting** — Any positions with unrealized losses that could be harvested?\n3. **Capital Gains Exposure** — Large unrealized gains that may create future tax events?\n4. **TFSA Optimization** — Is the TFSA being used for highest-growth assets?\n5. **Recommendations** — Specific moves to improve after-tax returns\n\nReference Canadian tax rules. Be specific with numbers.`,
  rebalance: `You are a portfolio manager. Suggest specific rebalancing moves:\n\n1. **Current Allocation** — Break down by asset class, geography, and sector\n2. **Target vs Actual** — Assuming a balanced growth portfolio, what's over/underweight?\n3. **Specific Trades** — List exact positions to trim or add to\n4. **Priority Order** — Which changes have the highest impact?\n5. **Implementation** — Which accounts should each trade happen in?\n\nBe specific and actionable. Use CAD amounts.`,
  income: `You are a dividend and income analyst. Analyze this portfolio's income characteristics:\n\n1. **Estimated Annual Dividends** — By position and total\n2. **Yield Analysis** — Portfolio yield vs benchmark\n3. **Dividend Safety** — Any positions with at-risk dividends?\n4. **Growth vs Income** — Current balance and recommendations\n5. **Tax-Efficient Income** — Which account types hold which income producers?\n\nUse CAD. Be specific with dollar amounts.`,
};

// ─── Tab Management ──────────────────────────────────────────────────────────
function switchTab(tab) {
  activeTab = tab;
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.getElementById('panel-' + tab).classList.add('active');
  document.querySelectorAll('.tab-btn').forEach(b => {
    if (b.getAttribute('onclick') === "switchTab('" + tab + "')") b.classList.add('active');
  });
  renderActiveTab();
}

function renderActiveTab() {
  if (filteredPositions.length === 0) return;
  switch(activeTab) {
    case 'overview': renderOverview(); break;
    case 'holdings': renderHoldingsTab(); break;
    case 'sectors': renderSectors(); break;
    case 'performance': renderPerformance(); break;
    case 'risk': renderRisk(); break;
    case 'region': renderRegion(); break;
    case 'dividends': renderDividends(); break;
    case 'tax': renderTax(); break;
  }
}

// ─── Risk Slider ─────────────────────────────────────────────────────────────
function onRiskChange() {
  riskTolerance = parseInt(document.getElementById('riskSlider').value);
  const label = document.getElementById('riskLabel');
  if (riskTolerance <= 3) { label.textContent = 'Conservative'; label.style.color = 'var(--green)'; }
  else if (riskTolerance <= 5) { label.textContent = 'Moderate'; label.style.color = 'var(--yellow)'; }
  else if (riskTolerance <= 7) { label.textContent = 'Growth'; label.style.color = 'var(--orange)'; }
  else { label.textContent = 'Aggressive'; label.style.color = 'var(--red)'; }
  generateMoves();
}

// ─── Chart.js Defaults ──────────────────────────────────────────────────────
if (typeof Chart !== 'undefined') {
  Chart.defaults.color = '#94a3b8';
  Chart.defaults.borderColor = 'rgba(42, 53, 80, 0.5)';
  Chart.defaults.font.family = "'DM Sans', sans-serif";
}

// ─── Initialize Add-on ──────────────────────────────────────────────────────
if (typeof Addon === 'undefined') {
  console.error('wealthica.js failed to load');
  showToast('Running in demo mode', 'error');
  loadDemoData();
} else {
  try {
    addon = new Addon();
    let initReceived = false;
    setTimeout(function() { if (!initReceived) { showToast('Wealthica not detected — loading demo data', 'error'); addon = null; loadDemoData(); } }, 10000);
    addon.on('init', function(options) {
      initReceived = true;
      currentOptions = options;
      if (options.data && options.data.apiKey) {
        apiKey = options.data.apiKey;
        document.getElementById('apiKeyInput').value = apiKey;
        updateStatus('connected', 'API key loaded');
      }
      loadPortfolio();
    });
    addon.on('reload', function() { loadPortfolio(); });
    addon.on('update', function(options) { currentOptions = { ...currentOptions, ...options }; loadPortfolio(); });
  } catch(e) {
    console.log('Not running inside Wealthica.', e);
    showToast('Demo mode — not inside Wealthica', 'error');
    loadDemoData();
  }
}

// ─── Portfolio Loading ───────────────────────────────────────────────────────
function buildQuery(options) {
  return {
    from: options.dateRangeFilter && options.dateRangeFilter[0],
    to: options.dateRangeFilter && options.dateRangeFilter[1],
    groups: options.groupsFilter,
    institutions: options.institutionsFilter,
    investments: options.investmentsFilter === 'all' ? null : options.investmentsFilter,
  };
}

async function loadPortfolio() {
  if (!addon) return;
  try {
    const query = buildQuery(currentOptions);
    const [positions, institutions] = await Promise.all([
      addon.api.getPositions(query),
      addon.api.getInstitutions(query),
    ]);
    portfolioData.positions = positions || [];
    portfolioData.institutions = institutions || [];
    processPortfolio();
    filteredPositions = [...portfolioData.positions];
    populateAccountFilter();
    renderAllTabs();
    document.getElementById('btnAnalyze').disabled = !apiKey;
    if (portfolioData.positions.length > 0) showToast('Loaded ' + portfolioData.positions.length + ' positions', 'success');
  } catch(err) {
    console.error('Failed to load portfolio:', err);
    showToast('Failed to load: ' + (err.message || err), 'error');
  }
}

function processPortfolio() {
  let totalValue = 0, totalBook = 0;

  // Build institution/investment lookup — handle both string IDs and object refs
  const instMap = {};
  const invMap = {};
  portfolioData.institutions.forEach(inst => {
    const iid = inst._id || inst.id;
    if (iid) instMap[iid] = inst;
    // Also index by name for fallback matching
    if (inst.name) instMap['name:' + inst.name.toLowerCase()] = inst;
    if (inst.investments) {
      inst.investments.forEach(inv => {
        const vid = inv._id || inv.id;
        const invLabel = inv.name || inv.type || '';
        const instLabel = inst.name || '';
        const fullLabel = invLabel && instLabel ? invLabel + ' - ' + instLabel : invLabel || instLabel;
        if (vid) invMap[vid] = { instName: instLabel, invName: invLabel, fullName: fullLabel };
        // Wealthica investment IDs are often {accountId}:{type}:{currency}
        // Also index by the accountId portion for partial matching
        if (vid && vid.includes(':')) {
          const parts = vid.split(':');
          invMap['partial:' + parts[0]] = invMap['partial:' + parts[0]] || { instName: instLabel, invName: invLabel, fullName: fullLabel };
        }
      });
    }
  });

  portfolioData.positions.forEach(pos => {
    const mv = pos.market_value || pos.value || 0;
    const bv = pos.book_value || mv;
    totalValue += mv;
    totalBook += bv;

    // Resolve account name from investment > institution > fallback
    if (pos._accountName) return; // already set (e.g., demo data)

    const investId = typeof pos.investment === 'object' ? (pos.investment?._id || pos.investment?.id) : pos.investment;
    const instId = typeof pos.institution === 'object' ? (pos.institution?._id || pos.institution?.id) : pos.institution;

    // 1. Direct investment ID match
    if (investId && invMap[investId]) {
      pos._accountName = invMap[investId].fullName;
    }
    // 2. Partial investment ID match (match on accountId portion before ':')
    else if (investId && investId.includes(':') && invMap['partial:' + investId.split(':')[0]]) {
      pos._accountName = invMap['partial:' + investId.split(':')[0]].fullName;
    }
    // 3. Investment ID is actually an institution ID
    else if (investId && instMap[investId]) {
      pos._accountName = instMap[investId].name;
    }
    // 4. Direct institution ID match
    else if (instId && instMap[instId]) {
      pos._accountName = instMap[instId].name;
    }
    // 5. Institution string that might be a name
    else if (pos.institution && typeof pos.institution === 'string') {
      const byName = instMap['name:' + pos.institution.toLowerCase()];
      pos._accountName = byName ? byName.name : pos.institution;
    }
    // 6. Try all available fields as fallback
    else {
      pos._accountName = pos.account_name || pos.accountName || pos.group || '';
      // If still empty, try to build from investment ID structure
      if (!pos._accountName && investId) {
        // Investment ID format: {accountId}:{type}:{currency}
        const parts = String(investId).split(':');
        if (parts.length >= 2) {
          const type = parts[1] || '';
          // Make the type human-readable
          const typeLabels = { 'tfsa': 'TFSA', 'rrsp': 'RRSP', 'rrif': 'RRIF', 'lira': 'LIRA', 'resp': 'RESP', 'margin': 'Non-Reg', 'cash': 'Cash', 'individual': 'Non-Reg', 'joint': 'Joint' };
          pos._accountName = typeLabels[type.toLowerCase()] || type || 'Account';
        } else {
          pos._accountName = 'Account';
        }
      }
      if (!pos._accountName) pos._accountName = 'Account';
    }
  });
  portfolioData.totalValue = totalValue;
  portfolioData.totalBook = totalBook;
}

// ─── Account Filter ──────────────────────────────────────────────────────────
function populateAccountFilter() {
  const sel = document.getElementById('accountFilter');
  const accounts = [...new Set(portfolioData.positions.map(p => p._accountName || 'Account'))].sort();
  sel.innerHTML = '<option value="all">All Accounts (' + portfolioData.positions.length + ' positions)</option>';

  // Add account type groups (TFSA, RRSP, Non-Reg)
  const groups = { 'TFSA': [], 'RRSP': [], 'Non-Registered': [], 'Other': [] };
  accounts.forEach(a => {
    if (/tfsa/i.test(a)) groups['TFSA'].push(a);
    else if (/rrsp|lira|rrif/i.test(a)) groups['RRSP'].push(a);
    else if (/non.reg|margin|taxable|individual|cash/i.test(a)) groups['Non-Registered'].push(a);
    else groups['Other'].push(a);
  });

  // Add group filters if there are multiple account types
  const activeGroups = Object.entries(groups).filter(([,v]) => v.length > 0);
  if (activeGroups.length > 1) {
    const groupOpt = document.createElement('optgroup');
    groupOpt.label = 'Account Types';
    activeGroups.forEach(([label, accts]) => {
      const count = portfolioData.positions.filter(p => accts.includes(p._accountName)).length;
      if (count > 0) {
        const o = document.createElement('option');
        o.value = 'group:' + label;
        o.textContent = label + ' (' + count + ' positions)';
        groupOpt.appendChild(o);
      }
    });
    sel.appendChild(groupOpt);
  }

  // Add individual accounts
  if (accounts.length > 0) {
    const acctOpt = document.createElement('optgroup');
    acctOpt.label = 'Individual Accounts';
    accounts.forEach(a => {
      const count = portfolioData.positions.filter(p => (p._accountName || 'Account') === a).length;
      const o = document.createElement('option');
      o.value = a;
      o.textContent = a + ' (' + count + ')';
      acctOpt.appendChild(o);
    });
    sel.appendChild(acctOpt);
  }
}

function applyAccountFilter() {
  const val = document.getElementById('accountFilter').value;
  if (val === 'all') {
    filteredPositions = [...portfolioData.positions];
  } else if (val.startsWith('group:')) {
    const groupName = val.replace('group:', '');
    filteredPositions = portfolioData.positions.filter(p => {
      const name = p._accountName || '';
      if (groupName === 'TFSA') return /tfsa/i.test(name);
      if (groupName === 'RRSP') return /rrsp|lira|rrif/i.test(name);
      if (groupName === 'Non-Registered') return /non.reg|margin|taxable|individual|cash/i.test(name) || (!/tfsa|rrsp|lira|rrif/i.test(name) && !/shakepay|crypto|newton|ndax/i.test(name));
      return true;
    });
  } else {
    filteredPositions = portfolioData.positions.filter(p => (p._accountName || 'Account') === val);
  }
  renderAllTabs();
}

function renderAllTabs() {
  renderSummary();
  renderAccounts();
  renderActiveTab();
  generateMoves();
}

// ─── Inference Functions ─────────────────────────────────────────────────────
function inferRegion(pos) {
  // Accept both a position object and a plain symbol string
  const symbol = typeof pos === 'string' ? pos : (pos?.security?.symbol || pos?.symbol || '');
  const category = typeof pos === 'string' ? '' : (pos?.category || '').toLowerCase();
  if (!symbol && !category) return 'Unknown';

  // 1. Use Wealthica's position-level category (e.g. "US Stocks", "Canadian Stocks")
  if (category) {
    if (/canad/i.test(category)) return 'Canada';
    if (/\bus\b|united states|american/i.test(category)) return 'United States';
    if (/international|global|emerging|europe|asia|japan|china|india|latin|eafe|frontier|developing/i.test(category)) return 'International';
    if (/crypto|digital/i.test(category)) return 'Crypto';
  }

  // 2. Fall back to symbol-based detection
  const s = symbol.toUpperCase();
  if (/\.(TO|TSX|V|VN|CN)$/i.test(s)) return 'Canada';
  if (['BTC','ETH','SOL','ADA','DOT','DOGE','XRP','LINK','AVAX','MATIC','USDT','USDC'].includes(s)) return 'Crypto';
  const intlETFs = ['XEF.TO','VIU.TO','XEC.TO','VEE.TO','ZEA.TO','VXUS','IXUS','EFA','EEM'];
  if (intlETFs.includes(s)) return 'International';
  if (/\.(L|LSE|PA|DE|AS|MI|MC|SW|HK|SS|SZ|T|AX)$/i.test(s)) return 'International';
  return 'United States';
}

function inferAssetClass(pos) {
  const sym = (pos.security?.symbol || pos.symbol || '').toUpperCase();
  const name = (pos.security?.name || pos.name || '').toLowerCase();
  const type = (pos.security?.type || pos.type || '').toLowerCase();
  // Wealthica API: class & category are at position level (pos.class, pos.category)
  const assetClass = (pos.class || pos.security?.asset_class || '').toLowerCase();
  const category = (pos.category || pos.security?.category || '').toLowerCase();

  // 1. Use Wealthica's class / category — short-circuit for non-equity types only
  //    For equity, fall through to detailed ETF/stock pattern matching below
  if (assetClass && !/equity|stock/i.test(assetClass)) {
    if (/crypto|digital/i.test(assetClass)) return 'Crypto';
    if (/fixed.income|bond|debt/i.test(assetClass)) return 'Fixed Income';
    if (/real.estate|reit/i.test(assetClass)) return 'Real Estate';
    if (/cash|money.market/i.test(assetClass)) return 'Cash';
    if (/commodity/i.test(assetClass)) return 'Commodities';
    if (/alternative/i.test(assetClass)) return 'Alternatives';
  }

  // 2. Use security type
  if (type === 'crypto' || type === 'cryptocurrency') return 'Crypto';
  if (type === 'bond' || type === 'fixed-income') return 'Fixed Income';
  if (type === 'cash' || type === 'money-market') return 'Cash';
  if (type === 'commodity') return 'Commodities';

  // 3. Symbol-based crypto detection
  const cryptos = ['BTC','ETH','SOL','ADA','DOT','DOGE','XRP','LINK','AVAX','MATIC','USDT','USDC','BNB','LTC','UNI','ATOM','NEAR','APT','ARB','OP','FTM','ALGO','XLM','VET','HBAR','FIL','ICP','SAND','MANA','AXS','CRO','SHIB','PEPE'];
  if (cryptos.includes(sym) || /^(BTC|ETH|SOL|XRP)\.(X|USD|CAD)$/.test(sym)) return 'Crypto';

  // 4. Broad diversified / all-in-one ETFs
  if (/^(XEQT|VEQT|XGRO|VGRO|XBAL|VBAL|XCNS|VCNS|XINC|VRIF)\.(TO|TSX)$/.test(sym) || ['VT','VTI','ITOT','ACWI'].includes(sym)) return 'Diversified';
  if (name.includes('all-in-one') || name.includes('all in one') || (name.includes('asset allocation') && name.includes('etf'))) return 'Diversified';

  // 5. Index / broad market ETFs
  if (/^(VFV|VSP|ZSP|HXS|XUS)\.(TO|TSX)$/.test(sym) || ['SPY','VOO','IVV','QQQ','DIA','IWM','RSP'].includes(sym)) return 'US Equity Index';
  if (/^(XIU|XIC|VCN|ZCN|HXT)\.(TO|TSX)$/.test(sym)) return 'Canadian Equity Index';

  // 6. Fixed income detection
  if (name.includes('bond') || name.includes('fixed income') || name.includes('aggregate') || name.includes('treasury') || name.includes('income fund') || name.includes('money market') || name.includes('savings')) return 'Fixed Income';
  if (/^(XBB|ZAG|VAB|ZDB|XSB|ZST|VSB|CLF|PSA|CSAV)\.(TO|TSX)$/.test(sym) || ['BND','AGG','TLT','HYG','LQD','SHY','IEF','VCIT','VCSH','BSV'].includes(sym)) return 'Fixed Income';

  // 7. Real estate
  if (name.includes('reit') || name.includes('real estate') || name.includes('property') || /\.UN\.(TO|TSX)$/.test(sym)) return 'Real Estate';
  if (/^(XRE|ZRE|VRE)\.(TO|TSX)$/.test(sym) || ['VNQ','XLRE','IYR','SCHH','RWR'].includes(sym)) return 'Real Estate';

  // 8. Equity sector inference from name/symbol
  return inferEquitySector(sym, name, category);
}

function inferEquitySector(sym, name, category) {
  // Category from Wealthica if available — match specific sector categories
  if (category) {
    if (/tech/i.test(category)) return 'Technology';
    if (/financ|bank/i.test(category)) return 'Financials';
    if (/energy|oil|gas/i.test(category)) return 'Energy';
    if (/health|pharma|biotech/i.test(category)) return 'Healthcare';
    if (/consumer.disc|retail/i.test(category)) return 'Consumer Discretionary';
    if (/consumer.stap/i.test(category)) return 'Consumer Staples';
    if (/industrial|aerospace|defense/i.test(category)) return 'Industrials';
    if (/material|mining|metal|gold|silver/i.test(category)) return 'Materials';
    if (/utilit/i.test(category)) return 'Utilities';
    if (/telecom|communicat/i.test(category)) return 'Communications';
    if (/real.estate|reit/i.test(category)) return 'Real Estate';
    if (/international|emerging|eafe|europe|asia|japan|china|frontier|developing/i.test(category)) return 'International Equity';
    if (/global|world|all.country/i.test(category)) return 'Diversified';
    // Broad categories like "US Stocks", "Canadian Stocks" — don't match, let symbol/name matching decide
  }

  // Name-based keyword matching (broad)
  if (/\b(tech|software|semiconductor|chip|cloud|cyber|data|digital|ai |artificial|compute|intel|microsoft|apple|google|meta |nvidia|amd |adobe|salesforce|oracle|sap |ibm )\b/.test(name) || /nasdaq|information tech/i.test(name)) return 'Technology';
  if (/^(XIT|ZQQ|TEC|XQQ|SHOP|OTEX|CSU|DCBO|KXS|LSPD)\.(TO|TSX)$/.test(sym) || ['QQQ','XLK','VGT','ARKK','SMH','SOXX','IGV','AAPL','MSFT','NVDA','GOOGL','GOOG','META','AMZN','CRM','ADBE','ORCL','INTC','AMD','AVGO','CSCO','TXN'].includes(sym)) return 'Technology';

  if (/\b(bank|financ|insurance|capital market|asset manage|wealth|brokerage|credit)\b/.test(name)) return 'Financials';
  if (/^(TD|RY|BMO|BNS|CM|NA|MFC|SLF|GWO|IFC|POW|IAG|EQB|CWB|LB)\.(TO|TSX)$/.test(sym) || /^(ZEB|ZWB|XFN)\.(TO|TSX)$/.test(sym) || ['JPM','BAC','GS','MS','WFC','C','BRK.B','V','MA','AXP','XLF','VFH','KRE'].includes(sym)) return 'Financials';

  if (/\b(energy|oil|gas|petroleum|pipeline|natural gas|crude|drilling|upstream|midstream|downstream)\b/.test(name)) return 'Energy';
  if (/^(ENB|TRP|SU|CNQ|CVE|IMO|HSE|PPL|KEY|IPL|MEG|WCP|ARX|TVE|BIR|PEY)\.(TO|TSX)$/.test(sym) || /^(XEG|ZEO)\.(TO|TSX)$/.test(sym) || ['XLE','VDE','OIH','XOP','FENY'].includes(sym)) return 'Energy';

  if (/\b(health|pharma|biotech|medical|hospital|therapeut|drug|diagnostic|genomic)\b/.test(name)) return 'Healthcare';
  if (['XLV','VHT','IBB','XBI','ARKG'].includes(sym) || /^(ZUH|XHC)\.(TO|TSX)$/.test(sym)) return 'Healthcare';

  if (/\b(consumer discret|retail|auto|restaurant|hotel|leisure|apparel|luxury|e-commerce|amazon|tesla|home depot|nike)\b/.test(name)) return 'Consumer Discretionary';
  if (['XLY','VCR','AMZN','TSLA','HD','NKE','MCD','SBUX','TJX','LOW'].includes(sym)) return 'Consumer Discretionary';

  if (/\b(consumer staple|food|beverage|grocery|household|tobacco|personal care|procter|costco|walmart|coca|pepsi)\b/.test(name)) return 'Consumer Staples';
  if (['XLP','VDC','PG','KO','PEP','COST','WMT'].includes(sym) || /^(ATD|L|MRU|SAP|EMP\.A)\.(TO|TSX)$/.test(sym)) return 'Consumer Staples';

  if (/\b(industrial|aerospace|defense|railway|railroad|transport|logistics|machin|equipment|construction|waste|infrastructure)\b/.test(name)) return 'Industrials';
  if (/^(CNR|CP|CAE|WSP|TFI|GFL|SNC|STN|RBA|ATA)\.(TO|TSX)$/.test(sym) || ['XLI','VIS','CAT','BA','HON','UPS','GE','MMM','LMT','RTX'].includes(sym)) return 'Industrials';

  if (/\b(gold|silver|mining|metal|copper|lithium|iron|steel|chemical|fertilizer|lumber|timber|material|resource)\b/.test(name)) return 'Materials';
  if (/^(ABX|NTR|FNV|AEM|K |WFG|CCL|LUN|FM |HBM|ERO|CS |TKO|AGI|WPM|PAAS|FR )\.(TO|TSX)$/.test(sym) || /^(XGD|XMA|ZGD)\.(TO|TSX)$/.test(sym) || ['GLD','IAU','SLV','GDX','GDXJ','XLB','XME','NEM'].includes(sym)) return 'Materials';

  if (/\b(utilit|electric|power|water|gas distribution|renewable|solar|wind|hydro|nuclear)\b/.test(name)) return 'Utilities';
  if (/^(FTS|EMA|H |AQN|CPX|BEP\.UN|NPI|INE|TA |ALA)\.(TO|TSX)$/.test(sym) || ['XLU','VPU','NEE','DUK','SO','AEP'].includes(sym)) return 'Utilities';

  if (/\b(telecom|communicat|media|entertainment|streaming|wireless|cable|broadcast|disney|netflix|google|meta |alphabet|comcast)\b/.test(name)) return 'Communications';
  if (/^(T|BCE|RCI\.B|QBR\.B|SJR\.B|CGO)\.(TO|TSX)$/.test(sym) || ['XLC','VOX','GOOGL','META','DIS','NFLX','CMCSA','TMUS','VZ','T'].includes(sym)) return 'Communications';

  if (/\b(international|emerging|global|world|eafe|europe|asia|japan|china|india|latin|frontier)\b/.test(name)) return 'International Equity';
  if (/^(XEF|VIU|XEC|VEE|ZEA|ZEM|XEM|VXC|ZDM)\.(TO|TSX)$/.test(sym) || ['VXUS','IXUS','EFA','EEM','VEA','VWO','IEMG','ACWX'].includes(sym)) return 'International Equity';

  // Fallback: use security type
  if (/etf|fund/i.test(name) && !name.includes('bond')) return 'Equity Fund';
  if (/preferred|pref/i.test(name)) return 'Preferred Shares';

  return 'Equity';
}

// ─── Scoring System ──────────────────────────────────────────────────────────
function computeScores() {
  const positions = filteredPositions;
  const totalVal = positions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  if (!positions.length || !totalVal) return emptyScores();

  const weights = positions.map(p => (p.market_value || p.value || 0) / totalVal);
  const n = positions.length;
  const uniqueSecurities = new Set(positions.map(p => p.security?.symbol || p.symbol)).size;
  const totalBook = positions.reduce((s,p) => s + (p.book_value || p.market_value || p.value || 0), 0);
  const totalReturn = totalBook > 0 ? ((totalVal - totalBook) / totalBook) * 100 : 0;

  // ── 1. Diversification (0-100) ──
  const hhi = weights.reduce((s,w) => s + w*w, 0);
  const minHHI = n > 0 ? 1/n : 1;
  const hhiScore = (n <= 1 || minHHI >= 1) ? 0 : Math.round((1 - (hhi - minHHI) / (1 - minHHI)) * 100);

  const sectors = {};
  positions.forEach(p => { const sec = inferAssetClass(p); sectors[sec] = (sectors[sec]||0) + (p.market_value||p.value||0); });
  const sectorCount = Object.keys(sectors).length;
  const sectorScore = Math.min(100, sectorCount * 15);

  const regions = {};
  positions.forEach(p => { const r = inferRegion(p); regions[r] = (regions[r]||0) + (p.market_value||p.value||0); });
  const regionCount = Object.keys(regions).filter(r => r !== 'Unknown').length;
  const regionScore = Math.min(100, regionCount * 30);

  const posCountScore = Math.min(100, uniqueSecurities * 8);
  const diversification = clamp(Math.round(hhiScore * 0.35 + sectorScore * 0.25 + regionScore * 0.2 + posCountScore * 0.2));
  const diversificationDetail = hhiScore >= 70
    ? uniqueSecurities + ' securities across ' + sectorCount + ' sectors and ' + regionCount + ' regions. Weight distribution is well-balanced.'
    : hhiScore >= 40
    ? 'Moderate spread across ' + sectorCount + ' sectors. Consider adding more variety in ' + (regionCount < 3 ? 'geographic regions' : 'asset classes') + '.'
    : 'Heavily concentrated. Only ' + uniqueSecurities + ' unique securities in ' + sectorCount + ' sector(s). Add broad-market ETFs for instant diversification.';

  // ── 2. Risk Management (0-100) ──
  const maxW = Math.max(...weights) * 100;
  const top3W = [...weights].sort((a,b)=>b-a).slice(0,3).reduce((s,w)=>s+w,0) * 100;
  const top5W = [...weights].sort((a,b)=>b-a).slice(0,5).reduce((s,w)=>s+w,0) * 100;
  const concScore = clamp(Math.round(100 - maxW * 1.5));
  const top3Score = clamp(Math.round(100 - Math.max(0, top3W - 40)));
  const homeBias = (regions['Canada']||0) / totalVal * 100;
  const homeScore = homeBias > 80 ? 20 : homeBias > 60 ? 50 : homeBias > 40 ? 80 : 90;

  // Volatility proxy: crypto + single stocks as % of portfolio
  const cryptoWeight = Object.entries(sectors).filter(([k]) => k === 'Crypto').reduce((s,[,v]) => s + v, 0) / totalVal * 100;
  const volPenalty = Math.min(40, cryptoWeight * 1.5);
  const volScore = clamp(100 - Math.round(volPenalty));

  const riskManagement = clamp(Math.round(concScore * 0.3 + top3Score * 0.25 + homeScore * 0.2 + volScore * 0.25));
  const riskDetail = maxW > 30
    ? 'High single-position risk: top holding is ' + maxW.toFixed(1) + '% of portfolio. Top 3 holdings = ' + top3W.toFixed(1) + '%. Trim overweight positions to reduce concentration.'
    : maxW > 15
    ? 'Moderate concentration with top holding at ' + maxW.toFixed(1) + '%. Top 5 = ' + top5W.toFixed(1) + '%. ' + (homeBias > 60 ? 'Canadian home bias at ' + homeBias.toFixed(0) + '% — add international exposure.' : 'Geographic mix looks reasonable.')
    : 'Well-managed risk profile. No single position exceeds 15%. ' + (cryptoWeight > 10 ? 'Crypto allocation (' + cryptoWeight.toFixed(1) + '%) adds volatility — appropriate for aggressive profiles only.' : 'Volatility exposure is controlled.');

  // ── 3. Performance (0-100) ──
  const posReturns = positions.map(p => {
    const mv = p.market_value || p.value || 0;
    const bv = p.book_value || mv;
    return bv > 0 ? ((mv - bv) / bv) * 100 : 0;
  });
  const avgReturn = posReturns.reduce((s,r) => s + r, 0) / posReturns.length;
  const winners = posReturns.filter(r => r > 0).length;
  const winRate = (winners / posReturns.length) * 100;
  const returnScore = clamp(Math.round(50 + totalReturn * 2));
  const winRateScore = clamp(Math.round(winRate));
  const consistencyScore = clamp(Math.round(100 - Math.min(80, Math.abs(avgReturn - totalReturn) * 2)));
  const performance = clamp(Math.round(returnScore * 0.5 + winRateScore * 0.3 + consistencyScore * 0.2));
  const performanceDetail = totalReturn > 15
    ? 'Strong returns of ' + pct(totalReturn) + ' overall. ' + winners + '/' + posReturns.length + ' positions profitable (' + winRate.toFixed(0) + '% win rate). Average position return: ' + pct(avgReturn) + '.'
    : totalReturn > 0
    ? 'Positive returns of ' + pct(totalReturn) + '. ' + winners + '/' + posReturns.length + ' positions in the green. Consider reviewing underperformers for tax-loss harvesting opportunities.'
    : 'Negative returns of ' + pct(totalReturn) + '. ' + (posReturns.length - winners) + ' positions with unrealized losses. Review thesis for each loser — harvest tax losses or average down if conviction remains.';

  // ── 4. Tax Efficiency (0-100) ──
  const accounts = {};
  positions.forEach(p => { const a = p._accountName || ''; accounts[a] = (accounts[a] || []).concat(p); });
  let taxScore = 70; // base
  const taxIssues = [];
  Object.entries(accounts).forEach(([name, poss]) => {
    const isRRSP = /rrsp|lira|rrif/i.test(name);
    const isTFSA = /tfsa/i.test(name);
    const isNonReg = !isRRSP && !isTFSA;
    poss.forEach(p => {
      const sym = (p.security?.symbol||p.symbol||'').toUpperCase();
      const cur = p.security?.currency || p.currency || 'CAD';
      const sector = inferAssetClass(p);
      // US dividends in non-RRSP lose 15% withholding
      if (cur === 'USD' && !isRRSP && (sector.includes('Equity') || sector === 'Financials' || sector === 'Technology' || sector === 'Healthcare')) {
        taxScore -= 3;
        taxIssues.push(sym + ' (USD dividend payer) in non-RRSP — loses 15% withholding tax');
      }
      // Growth stocks in RRSP instead of TFSA
      if (isRRSP && sector === 'Crypto') { taxScore -= 5; taxIssues.push(sym + ' in RRSP — crypto growth is better sheltered in TFSA'); }
      // Unrealized losses in registered accounts (can\'t harvest)
      const gl = (p.market_value||p.value||0) - (p.book_value||0);
      if (gl < -1000 && !isNonReg) { taxScore -= 2; taxIssues.push(sym + ' has ' + fmt(gl) + ' unrealized loss in registered account — cannot tax-loss harvest'); }
    });
  });
  const taxEfficiency = clamp(Math.round(taxScore));
  const taxDetail = taxIssues.length === 0
    ? 'No major tax efficiency issues detected. Holdings appear well-placed across account types.'
    : 'Found ' + taxIssues.length + ' tax efficiency issue(s): ' + taxIssues.slice(0, 3).join('; ') + (taxIssues.length > 3 ? '; and ' + (taxIssues.length - 3) + ' more.' : '.');

  // ── 5. Income Potential (0-100) ──
  const incomePositions = positions.filter(p => {
    const sec = inferAssetClass(p);
    return sec === 'Fixed Income' || sec === 'Real Estate' || sec === 'Utilities' || sec === 'Financials' || sec === 'Energy' || sec === 'Preferred Shares';
  });
  const incomeWeight = incomePositions.reduce((s,p) => s + (p.market_value||p.value||0), 0) / totalVal * 100;
  const targetIncome = riskTolerance <= 3 ? 40 : riskTolerance <= 5 ? 25 : riskTolerance <= 7 ? 15 : 5;
  const incomeGap = Math.abs(incomeWeight - targetIncome);
  const incomeScore = clamp(Math.round(100 - incomeGap * 2));
  const incomeDetail = incomeWeight > 5
    ? incomeWeight.toFixed(1) + '% of portfolio in income-oriented holdings (target ~' + targetIncome + '% for your risk profile). ' + incomePositions.length + ' income-generating positions.'
    : 'Very low income allocation (' + incomeWeight.toFixed(1) + '%). Portfolio is growth-oriented. ' + (riskTolerance <= 5 ? 'Consider adding dividend ETFs or bond allocation.' : 'Appropriate for aggressive growth strategy.');

  // ── Overall Health Score ──
  const health = clamp(Math.round(
    diversification * 0.25 +
    riskManagement * 0.25 +
    performance * 0.20 +
    taxEfficiency * 0.15 +
    incomeScore * 0.15
  ));

  const healthDetail = health >= 80
    ? 'Excellent portfolio health. Well-diversified, risk-managed, and tax-efficient.'
    : health >= 60
    ? 'Good portfolio health with room for improvement. Focus on: ' + (diversification < 60 ? 'diversification' : riskManagement < 60 ? 'risk management' : taxEfficiency < 60 ? 'tax efficiency' : 'income allocation') + '.'
    : health >= 40
    ? 'Fair portfolio health. Multiple areas need attention. Key issues: ' + [diversification < 50 ? 'low diversification' : '', riskManagement < 50 ? 'high concentration' : '', performance < 40 ? 'poor performance' : ''].filter(Boolean).join(', ') + '.'
    : 'Portfolio needs significant restructuring. Consider consulting a financial advisor or moving to a balanced all-in-one ETF.';

  return {
    health, healthDetail,
    diversification, diversificationDetail,
    riskManagement, riskDetail,
    performance, performanceDetail,
    taxEfficiency, taxDetail,
    income: incomeScore, incomeDetail,
    // Raw data for other uses
    maxConcentration: maxW, top3Concentration: top3W, top5Concentration: top5W,
    totalReturn, hhi, homeBias, cryptoWeight,
    sectorCount, regionCount, uniqueSecurities,
    winRate, avgReturn, winners, losers: posReturns.length - winners,
    incomeWeight, taxIssues,
  };
}

function emptyScores() {
  return { health: 0, healthDetail: 'No data loaded.', diversification: 0, diversificationDetail: '', riskManagement: 0, riskDetail: '', performance: 0, performanceDetail: '', taxEfficiency: 0, taxDetail: '', income: 0, incomeDetail: '', maxConcentration: 0, top3Concentration: 0, top5Concentration: 0, totalReturn: 0, hhi: 0, homeBias: 0, cryptoWeight: 0, sectorCount: 0, regionCount: 0, uniqueSecurities: 0, winRate: 0, avgReturn: 0, winners: 0, losers: 0, incomeWeight: 0, taxIssues: [] };
}

function clamp(v) { return Math.max(0, Math.min(100, v)); }

function scoreColor(score) {
  if (score >= 70) return 'var(--green)';
  if (score >= 40) return 'var(--yellow)';
  return 'var(--red)';
}

function scoreLabel(score) {
  if (score >= 80) return 'Excellent';
  if (score >= 60) return 'Good';
  if (score >= 40) return 'Fair';
  if (score >= 20) return 'Needs Work';
  return 'Critical';
}

// ─── Rendering Helpers ───────────────────────────────────────────────────────
function fmt(n, decimals) {
  if (decimals === undefined) decimals = 0;
  if (n === undefined || n === null || isNaN(n)) return '--';
  return new Intl.NumberFormat('en-CA', { style: 'currency', currency: 'CAD', minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(n);
}
function pct(n) { if (n === undefined || n === null || isNaN(n)) return ''; return (n >= 0 ? '+' : '') + n.toFixed(2) + '%'; }
function escapeHtml(str) { const d = document.createElement('div'); d.textContent = str; return d.innerHTML; }

function makeChart(key, ctx, config) {
  if (charts[key]) charts[key].destroy();
  charts[key] = new Chart(ctx, config);
}

// ─── Overview Rendering ──────────────────────────────────────────────────────
function renderSummary() {
  const totalValue = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const totalBook = filteredPositions.reduce((s,p) => s + (p.book_value || p.market_value || p.value || 0), 0);
  const gainLoss = totalValue - totalBook;
  const gainLossPctVal = totalBook > 0 ? ((totalValue - totalBook) / totalBook) * 100 : 0;
  const accounts = [...new Set(filteredPositions.map(p => p._accountName).filter(Boolean))];

  document.getElementById('totalValue').textContent = fmt(totalValue);
  document.getElementById('totalAccounts').textContent = accounts.length + ' account' + (accounts.length !== 1 ? 's' : '');
  document.getElementById('totalPositions').textContent = filteredPositions.length;
  const uniq = new Set(filteredPositions.map(p => p.security?.symbol || p.symbol).filter(Boolean));
  document.getElementById('positionsSub').textContent = uniq.size + ' unique securities';
  const glEl = document.getElementById('totalGainLoss');
  glEl.textContent = fmt(gainLoss);
  glEl.className = 'value ' + (gainLoss >= 0 ? 'positive' : 'negative');
  document.getElementById('gainLossPct').textContent = pct(gainLossPctVal);
  document.getElementById('gainLossPct').className = 'sub ' + (gainLoss >= 0 ? 'positive' : 'negative');

  if (filteredPositions.length > 0) {
    const sorted = [...filteredPositions].sort((a,b) => (b.market_value||b.value||0) - (a.market_value||a.value||0));
    const top = sorted[0];
    document.getElementById('topHolding').textContent = top.security?.symbol || top.symbol || 'N/A';
    document.getElementById('topHoldingPct').textContent = (((top.market_value||top.value||0)/totalValue)*100).toFixed(1) + '% of portfolio';
  }

  // Health score
  const scores = computeScores();
  const circ = 2 * Math.PI * 42;
  const ring = document.getElementById('healthRingFill');
  ring.style.strokeDasharray = circ;
  ring.style.strokeDashoffset = circ * (1 - scores.health / 100);
  ring.style.stroke = scoreColor(scores.health);
  document.getElementById('healthScoreText').textContent = scores.health;
  document.getElementById('healthSummary').textContent = scores.healthDetail;

  // Render compact sub-scores in banner
  const subGrid = document.getElementById('subScores');
  subGrid.innerHTML = '';
  [
    { label: 'Diversification', value: scores.diversification },
    { label: 'Risk', value: scores.riskManagement },
    { label: 'Performance', value: scores.performance },
    { label: 'Tax', value: scores.taxEfficiency },
    { label: 'Income', value: scores.income },
  ].forEach(sub => {
    const d = document.createElement('div');
    d.style.cssText = 'background:var(--bg-primary);border-radius:6px;padding:6px 10px;';
    d.innerHTML = '<div style="font-size:10px;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.3px">' + sub.label + '</div>' +
      '<div style="display:flex;align-items:center;gap:6px;margin-top:2px"><span style="font-family:JetBrains Mono,monospace;font-size:14px;font-weight:600;color:' + scoreColor(sub.value) + '">' + sub.value + '</span>' +
      '<div style="flex:1;height:3px;background:var(--border);border-radius:2px;overflow:hidden"><div style="height:100%;width:' + sub.value + '%;background:' + scoreColor(sub.value) + ';border-radius:2px"></div></div></div>';
    subGrid.appendChild(d);
  });

  // Render detailed score breakdown cards
  const breakdownGrid = document.getElementById('scoreBreakdown');
  breakdownGrid.innerHTML = '';
  [
    { label: 'Diversification', weight: '25%', value: scores.diversification, desc: scores.diversificationDetail },
    { label: 'Risk Management', weight: '25%', value: scores.riskManagement, desc: scores.riskDetail },
    { label: 'Performance', weight: '20%', value: scores.performance, desc: scores.performanceDetail },
    { label: 'Tax Efficiency', weight: '15%', value: scores.taxEfficiency, desc: scores.taxDetail },
    { label: 'Income Potential', weight: '15%', value: scores.income, desc: scores.incomeDetail },
  ].forEach(item => {
    const color = scoreColor(item.value);
    const grade = scoreLabel(item.value);
    const gradeBg = item.value >= 70 ? 'var(--green-bg)' : item.value >= 40 ? 'var(--yellow-bg)' : 'var(--red-bg)';
    const d = document.createElement('div');
    d.className = 'score-breakdown-card';
    d.innerHTML = '<div class="sbc-header"><span class="sbc-label">' + item.label + '</span><span class="sbc-weight">' + item.weight + ' weight</span></div>' +
      '<div class="sbc-score"><span class="sbc-value" style="color:' + color + '">' + item.value + '</span>' +
      '<div class="sbc-bar-wrap"><div class="sbc-bar"><div class="sbc-bar-fill" style="width:' + item.value + '%;background:' + color + '"></div></div></div>' +
      '<span class="sbc-grade" style="color:' + color + ';background:' + gradeBg + '">' + grade + '</span></div>' +
      '<div class="sbc-desc">' + escapeHtml(item.desc) + '</div>';
    breakdownGrid.appendChild(d);
  });

  // Render key insights panel
  const insights = [];
  if (scores.maxConcentration > 20) insights.push({ color: 'var(--red)', text: '<strong>High concentration:</strong> Top position is ' + scores.maxConcentration.toFixed(1) + '% of portfolio. Consider trimming to below 15%.' });
  if (scores.homeBias > 60) insights.push({ color: 'var(--yellow)', text: '<strong>Canadian home bias:</strong> ' + scores.homeBias.toFixed(0) + '% in Canada (only ~3% of global market cap). Add international diversification.' });
  if (scores.cryptoWeight > 15) insights.push({ color: 'var(--yellow)', text: '<strong>High crypto exposure:</strong> ' + scores.cryptoWeight.toFixed(1) + '% in crypto adds significant volatility.' });
  if (scores.totalReturn > 10) insights.push({ color: 'var(--green)', text: '<strong>Strong performance:</strong> Portfolio up ' + pct(scores.totalReturn) + ' overall with ' + scores.winRate.toFixed(0) + '% win rate.' });
  if (scores.totalReturn < -5) insights.push({ color: 'var(--red)', text: '<strong>Underperforming:</strong> Portfolio down ' + pct(scores.totalReturn) + '. Review losers for tax-loss harvesting.' });
  if (scores.taxIssues.length > 0) insights.push({ color: 'var(--yellow)', text: '<strong>' + scores.taxIssues.length + ' tax issue(s):</strong> ' + scores.taxIssues[0] });
  if (scores.sectorCount < 4) insights.push({ color: 'var(--yellow)', text: '<strong>Limited sectors:</strong> Only ' + scores.sectorCount + ' sectors. Consider broad-market ETFs for more diversification.' });
  if (scores.regionCount >= 3 && scores.homeBias <= 60) insights.push({ color: 'var(--green)', text: '<strong>Good geographic spread:</strong> ' + scores.regionCount + ' regions represented with no excessive home bias.' });
  if (filteredPositions.length >= 10 && scores.diversification >= 60) insights.push({ color: 'var(--green)', text: '<strong>Well diversified:</strong> ' + scores.uniqueSecurities + ' unique securities across ' + scores.sectorCount + ' sectors.' });

  const insightsPanel = document.getElementById('insightsPanel');
  const insightsList = document.getElementById('insightsList');
  if (insights.length > 0) {
    insightsPanel.style.display = 'block';
    insightsList.innerHTML = '';
    insights.forEach(insight => {
      const d = document.createElement('div');
      d.className = 'insight-item';
      d.innerHTML = '<div class="insight-dot" style="background:' + insight.color + '"></div><div class="insight-text">' + insight.text + '</div>';
      insightsList.appendChild(d);
    });
  } else {
    insightsPanel.style.display = 'none';
  }
}

function renderOverview() {
  const totalValue = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);

  // Allocation chart (by type/sector)
  const sectorMap = {};
  filteredPositions.forEach(p => {
    const sector = inferAssetClass(p);
    sectorMap[sector] = (sectorMap[sector] || 0) + (p.market_value || p.value || 0);
  });
  const sectorEntries = Object.entries(sectorMap).sort((a,b) => b[1] - a[1]);
  makeChart('allocation', document.getElementById('allocationChart'), {
    type: 'doughnut',
    data: { labels: sectorEntries.map(e=>e[0]), datasets: [{ data: sectorEntries.map(e=>e[1]), backgroundColor: CHART_COLORS.slice(0, sectorEntries.length), borderWidth: 0 }] },
    options: { responsive: true, maintainAspectRatio: true, cutout: '60%', plugins: { legend: { position: 'bottom', labels: { padding: 10, usePointStyle: true, pointStyleWidth: 8, font: { size: 11 } } } } }
  });

  // Top holdings bar chart
  const sorted = [...filteredPositions].sort((a,b) => (b.market_value||b.value||0) - (a.market_value||a.value||0)).slice(0, 8);
  makeChart('topHoldings', document.getElementById('topHoldingsChart'), {
    type: 'bar',
    data: {
      labels: sorted.map(p => p.security?.symbol || p.symbol || '?'),
      datasets: [{ data: sorted.map(p => p.market_value || p.value || 0), backgroundColor: '#3b82f6', borderRadius: 4 }]
    },
    options: { indexAxis: 'y', responsive: true, maintainAspectRatio: true, plugins: { legend: { display: false } }, scales: { x: { grid: { color: 'rgba(42,53,80,0.3)' }, ticks: { callback: v => '$' + (v/1000).toFixed(0) + 'k' } }, y: { grid: { display: false } } } }
  });
}

function renderAccounts() {
  const grid = document.getElementById('accountsGrid');
  grid.innerHTML = '';
  const acctValues = {};
  filteredPositions.forEach(pos => {
    const name = pos._accountName || 'Unknown';
    acctValues[name] = (acctValues[name] || 0) + (pos.market_value || pos.value || 0);
  });
  Object.entries(acctValues).sort((a,b) => b[1] - a[1]).forEach(([name, value]) => {
    const chip = document.createElement('div');
    chip.className = 'account-chip';
    chip.innerHTML = '<div class="acct-name">' + escapeHtml(name) + '</div><div class="acct-value">' + fmt(value) + '</div>';
    grid.appendChild(chip);
  });
}

// ─── Holdings Tab ────────────────────────────────────────────────────────────
function renderHoldingsTab() {
  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const sortBy = document.getElementById('holdingsSort').value;

  let sorted = [...filteredPositions];
  switch(sortBy) {
    case 'value': sorted.sort((a,b) => (b.market_value||b.value||0) - (a.market_value||a.value||0)); break;
    case 'gainloss': sorted.sort((a,b) => ((b.market_value||b.value||0)-(b.book_value||0)) - ((a.market_value||a.value||0)-(a.book_value||0))); break;
    case 'return': sorted.sort((a,b) => { const ra = a.book_value ? ((a.market_value||a.value||0)-a.book_value)/a.book_value : 0; const rb = b.book_value ? ((b.market_value||b.value||0)-b.book_value)/b.book_value : 0; return rb - ra; }); break;
    case 'weight': sorted.sort((a,b) => (b.market_value||b.value||0) - (a.market_value||a.value||0)); break;
    case 'name': sorted.sort((a,b) => ((a.security?.symbol||a.symbol||'') ).localeCompare(b.security?.symbol||b.symbol||'')); break;
    case 'rating': sorted.sort((a,b) => (positionRatings[b.security?.symbol||b.symbol]?.score||0) - (positionRatings[a.security?.symbol||a.symbol]?.score||0)); break;
  }

  const grid = document.getElementById('holdingsGrid');
  grid.innerHTML = '';

  sorted.forEach(pos => {
    const sym = pos.security?.symbol || pos.symbol || '--';
    const name = pos.security?.name || '';
    const mv = pos.market_value || pos.value || 0;
    const bv = pos.book_value || mv;
    const gl = mv - bv;
    const ret = bv > 0 ? ((mv - bv)/bv)*100 : 0;
    const weight = totalVal > 0 ? (mv/totalVal)*100 : 0;
    const rating = positionRatings[sym];

    const card = document.createElement('div');
    card.className = 'position-card';
    let ratingHTML = '';
    if (rating) {
      const rClass = rating.score >= 8 ? 'excellent' : rating.score >= 6 ? 'good' : rating.score >= 4 ? 'fair' : 'poor';
      const recClass = (rating.recommendation || '').toLowerCase().replace(/\s+/g, '-');
      ratingHTML = '<div class="rating-badge ' + rClass + '">' + rating.score + '</div>';
      ratingHTML += '<div><span class="rec-chip ' + recClass + '">' + escapeHtml(rating.recommendation || '') + '</span></div>';
      if (rating.reasoning) ratingHTML += '<div class="pos-reasoning">"' + escapeHtml(rating.reasoning) + '"</div>';
    }

    card.innerHTML = '<div class="pos-header"><div><div class="pos-symbol">' + escapeHtml(sym) + '</div>' +
      (name ? '<div class="pos-name">' + escapeHtml(name) + '</div>' : '') +
      '<div class="pos-account">' + escapeHtml(pos._accountName || '--') + '</div></div>' +
      (rating ? '<div style="text-align:right">' + ratingHTML + '</div>' : '') +
      '</div><div class="pos-values">' +
      '<div class="pos-metric"><div class="pm-label">Value</div><div class="pm-value">' + fmt(mv) + '</div></div>' +
      '<div class="pos-metric"><div class="pm-label">Gain/Loss</div><div class="pm-value ' + (gl>=0?'positive':'negative') + '">' + fmt(gl) + ' (' + pct(ret) + ')</div></div>' +
      '<div class="pos-metric"><div class="pm-label">Quantity</div><div class="pm-value">' + (pos.quantity != null ? Number(pos.quantity).toLocaleString('en-CA',{maximumFractionDigits:4}) : '--') + '</div></div>' +
      '<div class="pos-metric"><div class="pm-label">Book Value</div><div class="pm-value">' + fmt(bv) + '</div></div>' +
      '</div><div class="pos-weight-bar"><div class="pos-weight-fill" style="width:' + Math.min(100,weight) + '%"></div></div>' +
      '<div class="pos-weight-label">' + weight.toFixed(1) + '% of portfolio</div>';
    grid.appendChild(card);
  });

  // Weight chart
  const topN = sorted.slice(0, 12);
  makeChart('holdingsWeight', document.getElementById('holdingsWeightChart'), {
    type: 'bar',
    data: {
      labels: topN.map(p => p.security?.symbol || p.symbol || '?'),
      datasets: [{ label: 'Weight %', data: topN.map(p => totalVal > 0 ? ((p.market_value||p.value||0)/totalVal*100) : 0), backgroundColor: CHART_COLORS.slice(0, topN.length), borderRadius: 4 }]
    },
    options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { grid: { color: 'rgba(42,53,80,0.3)' }, ticks: { callback: v => v + '%' } }, x: { grid: { display: false } } } }
  });
}

// ─── Performance Tab ─────────────────────────────────────────────────────────
function renderPerformance() {
  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const totalBook = filteredPositions.reduce((s,p) => s + (p.book_value || p.market_value || p.value || 0), 0);
  const totalGL = totalVal - totalBook;
  const totalRet = totalBook > 0 ? ((totalVal - totalBook) / totalBook) * 100 : 0;

  // Best/worst
  const withReturn = filteredPositions.map(p => {
    const mv = p.market_value || p.value || 0;
    const bv = p.book_value || mv;
    return { ...p, ret: bv > 0 ? ((mv-bv)/bv)*100 : 0, gl: mv - bv };
  }).sort((a,b) => b.ret - a.ret);
  const best = withReturn[0];
  const worst = withReturn[withReturn.length - 1];

  const grid = document.getElementById('perfSummaryGrid');
  grid.innerHTML = '';
  const cards = [
    { label: 'Total Return', value: pct(totalRet), cls: totalRet >= 0 ? 'positive' : 'negative', sub: fmt(totalGL) },
    { label: 'Best Performer', value: best ? (best.security?.symbol || best.symbol || '--') : '--', cls: 'positive', sub: best ? pct(best.ret) : '' },
    { label: 'Worst Performer', value: worst ? (worst.security?.symbol || worst.symbol || '--') : '--', cls: worst && worst.ret < 0 ? 'negative' : '', sub: worst ? pct(worst.ret) : '' },
    { label: 'Avg Return', value: pct(withReturn.length > 0 ? withReturn.reduce((s,p)=>s+p.ret,0)/withReturn.length : 0), cls: '', sub: filteredPositions.length + ' positions' },
  ];
  cards.forEach(c => {
    const d = document.createElement('div');
    d.className = 'summary-card';
    d.innerHTML = '<div class="label">' + c.label + '</div><div class="value ' + c.cls + '" style="font-size:16px">' + c.value + '</div><div class="sub">' + c.sub + '</div>';
    grid.appendChild(d);
  });

  // Gain/loss by position
  const glSorted = [...withReturn].sort((a,b) => b.gl - a.gl);
  makeChart('gainLoss', document.getElementById('gainLossChart'), {
    type: 'bar',
    data: {
      labels: glSorted.map(p => p.security?.symbol || p.symbol || '?'),
      datasets: [{ data: glSorted.map(p => p.gl), backgroundColor: glSorted.map(p => p.gl >= 0 ? '#22c55e' : '#ef4444'), borderRadius: 4 }]
    },
    options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { grid: { color: 'rgba(42,53,80,0.3)' }, ticks: { callback: v => '$' + (v/1000).toFixed(1) + 'k' } }, x: { grid: { display: false } } } }
  });

  // By account
  const acctPerf = {};
  filteredPositions.forEach(p => {
    const a = p._accountName || 'Unknown';
    if (!acctPerf[a]) acctPerf[a] = { mv: 0, bv: 0 };
    acctPerf[a].mv += (p.market_value || p.value || 0);
    acctPerf[a].bv += (p.book_value || p.market_value || p.value || 0);
  });
  const acctEntries = Object.entries(acctPerf).sort((a,b) => (b[1].mv-b[1].bv) - (a[1].mv-a[1].bv));
  makeChart('accountPerf', document.getElementById('accountPerfChart'), {
    type: 'bar',
    data: {
      labels: acctEntries.map(e => e[0]),
      datasets: [
        { label: 'Book Value', data: acctEntries.map(e => e[1].bv), backgroundColor: 'rgba(59,130,246,0.3)', borderRadius: 4 },
        { label: 'Market Value', data: acctEntries.map(e => e[1].mv), backgroundColor: '#3b82f6', borderRadius: 4 },
      ]
    },
    options: { responsive: true, plugins: { legend: { position: 'bottom', labels: { usePointStyle: true, pointStyleWidth: 8 } } }, scales: { y: { grid: { color: 'rgba(42,53,80,0.3)' }, ticks: { callback: v => '$' + (v/1000).toFixed(0) + 'k' } }, x: { grid: { display: false } } } }
  });
}

// ─── Risk Tab ────────────────────────────────────────────────────────────────
function renderRisk() {
  const scores = computeScores();
  const grid = document.getElementById('riskScoresGrid');
  grid.innerHTML = '';
  [
    { label: 'Diversification', value: scores.diversification, color: scoreColor(scores.diversification) },
    { label: 'Risk Mgmt', value: scores.riskManagement, color: scoreColor(scores.riskManagement) },
    { label: 'Performance', value: scores.performance, color: scoreColor(scores.performance) },
    { label: 'Tax Efficiency', value: scores.taxEfficiency, color: scoreColor(scores.taxEfficiency) },
    { label: 'Income', value: scores.income, color: scoreColor(scores.income) },
    { label: 'Overall Health', value: scores.health, color: scoreColor(scores.health) },
  ].forEach(s => {
    const d = document.createElement('div');
    d.className = 'score-card';
    d.innerHTML = '<div class="sc-value" style="color:' + s.color + '">' + s.value + '</div><div class="sc-label">' + s.label + '</div><div class="sc-bar"><div class="sc-bar-fill" style="width:' + s.value + '%;background:' + s.color + '"></div></div>';
    grid.appendChild(d);
  });

  // Concentration chart
  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const sorted = [...filteredPositions].sort((a,b) => (b.market_value||b.value||0) - (a.market_value||a.value||0));
  const top5 = sorted.slice(0, 5);
  const rest = sorted.slice(5);
  const restVal = rest.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const concLabels = top5.map(p => p.security?.symbol || p.symbol || '?');
  const concData = top5.map(p => p.market_value || p.value || 0);
  if (restVal > 0) { concLabels.push('Others (' + rest.length + ')'); concData.push(restVal); }
  makeChart('concentration', document.getElementById('concentrationChart'), {
    type: 'doughnut',
    data: { labels: concLabels, datasets: [{ data: concData, backgroundColor: CHART_COLORS.slice(0, concLabels.length), borderWidth: 0 }] },
    options: { responsive: true, cutout: '55%', plugins: { legend: { position: 'bottom', labels: { padding: 8, usePointStyle: true, pointStyleWidth: 8, font: { size: 11 } } } } }
  });

  // Weight distribution
  const weights = sorted.map(p => ({ sym: p.security?.symbol || p.symbol || '?', w: totalVal > 0 ? (p.market_value||p.value||0)/totalVal*100 : 0 }));
  makeChart('riskWeights', document.getElementById('riskWeightsChart'), {
    type: 'bar',
    data: { labels: weights.map(w=>w.sym), datasets: [{ data: weights.map(w=>w.w), backgroundColor: weights.map(w => w.w > 20 ? '#ef4444' : w.w > 10 ? '#f59e0b' : '#3b82f6'), borderRadius: 4 }] },
    options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { grid: { color: 'rgba(42,53,80,0.3)' }, ticks: { callback: v => v + '%' } }, x: { grid: { display: false } } } }
  });

  // Risk factors
  const factors = [];
  if (scores.maxConcentration > 25) factors.push({ severity: 'high', title: 'High Single Position Concentration', desc: 'Your largest position is ' + scores.maxConcentration.toFixed(1) + '% of portfolio. Consider trimming to below 20%.' });
  else if (scores.maxConcentration > 15) factors.push({ severity: 'medium', title: 'Moderate Concentration', desc: 'Largest position is ' + scores.maxConcentration.toFixed(1) + '% — within acceptable range but monitor closely.' });
  if (scores.top3Concentration > 70) factors.push({ severity: 'high', title: 'Top 3 Holdings Dominate', desc: 'Top 3 positions represent ' + scores.top3Concentration.toFixed(1) + '% of your portfolio.' });
  if (filteredPositions.length < 5) factors.push({ severity: 'high', title: 'Too Few Positions', desc: 'Only ' + filteredPositions.length + ' positions. Consider adding more for diversification.' });
  else if (filteredPositions.length < 10) factors.push({ severity: 'medium', title: 'Limited Positions', desc: filteredPositions.length + ' positions. Adequate but more diversification could help.' });

  const sectorMap = {};
  filteredPositions.forEach(p => {
    const sec = inferAssetClass(p);
    sectorMap[sec] = (sectorMap[sec]||0) + (p.market_value||p.value||0);
  });
  Object.entries(sectorMap).forEach(([sec, val]) => {
    const pctVal = totalVal > 0 ? val/totalVal*100 : 0;
    if (pctVal > 40) factors.push({ severity: 'high', title: sec + ' Overweight', desc: sec + ' is ' + pctVal.toFixed(1) + '% of portfolio — heavy sector bet.' });
    else if (pctVal > 25) factors.push({ severity: 'medium', title: sec + ' Tilt', desc: sec + ' at ' + pctVal.toFixed(1) + '% — notable sector exposure.' });
  });

  const regionMap = {};
  filteredPositions.forEach(p => {
    const r = inferRegion(p);
    regionMap[r] = (regionMap[r]||0) + (p.market_value||p.value||0);
  });
  Object.entries(regionMap).forEach(([reg, val]) => {
    const pctVal = totalVal > 0 ? val/totalVal*100 : 0;
    if (pctVal > 60) factors.push({ severity: 'medium', title: reg + ' Heavy', desc: pctVal.toFixed(1) + '% in ' + reg + ' — consider international diversification.' });
  });

  if (factors.length === 0) factors.push({ severity: 'low', title: 'No Major Risks Detected', desc: 'Your portfolio appears well-balanced. Keep monitoring as markets change.' });

  const rfDiv = document.getElementById('riskFactors');
  rfDiv.innerHTML = '';
  factors.forEach(f => {
    const d = document.createElement('div');
    d.className = 'risk-factor';
    d.innerHTML = '<div class="severity ' + f.severity + '"></div><div><div class="rf-title">' + escapeHtml(f.title) + '</div><div class="rf-desc">' + escapeHtml(f.desc) + '</div></div>';
    rfDiv.appendChild(d);
  });
}

// ─── Region Tab ──────────────────────────────────────────────────────────────
function renderRegion() {
  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const regionMap = {}, currencyMap = {};
  filteredPositions.forEach(p => {
    const r = inferRegion(p);
    regionMap[r] = (regionMap[r]||0) + (p.market_value||p.value||0);
    const c = p.security?.currency || p.currency || 'CAD';
    currencyMap[c] = (currencyMap[c]||0) + (p.market_value||p.value||0);
  });

  const regionEntries = Object.entries(regionMap).sort((a,b) => b[1] - a[1]);
  const regionColors = { 'Canada': '#ef4444', 'United States': '#3b82f6', 'International': '#22c55e', 'Crypto': '#f59e0b', 'Unknown': '#64748b' };
  makeChart('geo', document.getElementById('geoChart'), {
    type: 'doughnut',
    data: { labels: regionEntries.map(e=>e[0]), datasets: [{ data: regionEntries.map(e=>e[1]), backgroundColor: regionEntries.map(e => regionColors[e[0]] || '#6366f1'), borderWidth: 0 }] },
    options: { responsive: true, cutout: '60%', plugins: { legend: { position: 'bottom', labels: { padding: 10, usePointStyle: true, pointStyleWidth: 8 } } } }
  });

  const currEntries = Object.entries(currencyMap).sort((a,b) => b[1] - a[1]);
  makeChart('currency', document.getElementById('currencyChart'), {
    type: 'doughnut',
    data: { labels: currEntries.map(e=>e[0]), datasets: [{ data: currEntries.map(e=>e[1]), backgroundColor: ['#3b82f6','#22c55e','#f59e0b','#ef4444','#a855f7'], borderWidth: 0 }] },
    options: { responsive: true, cutout: '60%', plugins: { legend: { position: 'bottom', labels: { padding: 10, usePointStyle: true, pointStyleWidth: 8 } } } }
  });

  const regionDiv = document.getElementById('regionCards');
  regionDiv.innerHTML = '';
  regionEntries.forEach(([name, value]) => {
    const pctVal = totalVal > 0 ? (value/totalVal*100) : 0;
    const posCount = filteredPositions.filter(p => inferRegion(p) === name).length;
    const d = document.createElement('div');
    d.className = 'region-card';
    d.innerHTML = '<div class="rc-name">' + escapeHtml(name) + '</div><div class="rc-pct">' + pctVal.toFixed(1) + '%</div><div class="rc-value">' + fmt(value) + ' · ' + posCount + ' position' + (posCount!==1?'s':'') + '</div><div class="rc-bar"><div class="rc-bar-fill" style="width:' + pctVal + '%;background:' + (regionColors[name]||'#6366f1') + '"></div></div>';
    regionDiv.appendChild(d);
  });
}

// ─── Sectors Tab ─────────────────────────────────────────────────────────────
function renderSectors() {
  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const sectorMap = {};
  filteredPositions.forEach(p => {
    const sec = inferAssetClass(p);
    if (!sectorMap[sec]) sectorMap[sec] = { value: 0, count: 0, positions: [] };
    sectorMap[sec].value += (p.market_value || p.value || 0);
    sectorMap[sec].count++;
    sectorMap[sec].positions.push(p);
  });
  const sectorEntries = Object.entries(sectorMap).sort((a,b) => b[1].value - a[1].value);

  // Doughnut chart
  makeChart('sectorDetail', document.getElementById('sectorDetailChart'), {
    type: 'doughnut',
    data: { labels: sectorEntries.map(e=>e[0]), datasets: [{ data: sectorEntries.map(e=>e[1].value), backgroundColor: CHART_COLORS.slice(0, sectorEntries.length), borderWidth: 0 }] },
    options: { responsive: true, cutout: '55%', plugins: { legend: { position: 'bottom', labels: { padding: 8, usePointStyle: true, pointStyleWidth: 8, font: { size: 11 } } } } }
  });

  // Bar chart
  makeChart('sectorBar', document.getElementById('sectorBarChart'), {
    type: 'bar',
    data: { labels: sectorEntries.map(e=>e[0]), datasets: [{ data: sectorEntries.map(e=>e[1].value), backgroundColor: CHART_COLORS.slice(0, sectorEntries.length), borderRadius: 4 }] },
    options: { indexAxis: 'y', responsive: true, plugins: { legend: { display: false } }, scales: { x: { grid: { color: 'rgba(42,53,80,0.3)' }, ticks: { callback: v => '$' + (v/1000).toFixed(0) + 'k' } }, y: { grid: { display: false } } } }
  });

  // Sector cards
  const grid = document.getElementById('sectorCards');
  grid.innerHTML = '';
  sectorEntries.forEach(([name, data], i) => {
    const pctVal = totalVal > 0 ? (data.value/totalVal*100) : 0;
    const gl = data.positions.reduce((s,p) => s + ((p.market_value||p.value||0) - (p.book_value||(p.market_value||p.value||0))), 0);
    const topSymbols = data.positions.sort((a,b) => (b.market_value||b.value||0) - (a.market_value||a.value||0)).slice(0,3).map(p => p.security?.symbol || p.symbol || '?').join(', ');
    const d = document.createElement('div');
    d.className = 'position-card';
    d.innerHTML = '<div class="pos-header"><div><div class="pos-symbol" style="color:' + CHART_COLORS[i % CHART_COLORS.length] + '">' + escapeHtml(name) + '</div>' +
      '<div class="pos-name">' + data.count + ' position' + (data.count!==1?'s':'') + ' · ' + topSymbols + '</div></div>' +
      '<div style="text-align:right"><div style="font-family:JetBrains Mono,monospace;font-size:18px;font-weight:700">' + pctVal.toFixed(1) + '%</div></div></div>' +
      '<div class="pos-values"><div class="pos-metric"><div class="pm-label">Value</div><div class="pm-value">' + fmt(data.value) + '</div></div>' +
      '<div class="pos-metric"><div class="pm-label">Gain/Loss</div><div class="pm-value ' + (gl>=0?'positive':'negative') + '">' + fmt(gl) + '</div></div></div>' +
      '<div class="pos-weight-bar"><div class="pos-weight-fill" style="width:' + Math.min(100,pctVal) + '%;background:' + CHART_COLORS[i % CHART_COLORS.length] + '"></div></div>';
    grid.appendChild(d);
  });
}

// ─── Dividends Tab ───────────────────────────────────────────────────────────
function renderDividends() {
  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const scores = computeScores();

  // Classify positions as income or growth
  const incomeTypes = ['Fixed Income','Real Estate','Utilities','Preferred Shares','Energy','Financials'];
  const incomePositions = [], growthPositions = [];
  filteredPositions.forEach(p => {
    const sec = inferAssetClass(p);
    if (incomeTypes.includes(sec)) incomePositions.push({ ...p, _sector: sec });
    else growthPositions.push({ ...p, _sector: sec });
  });
  const incomeVal = incomePositions.reduce((s,p) => s + (p.market_value||p.value||0), 0);
  const growthVal = growthPositions.reduce((s,p) => s + (p.market_value||p.value||0), 0);

  // Summary cards
  const grid = document.getElementById('divSummaryGrid');
  grid.innerHTML = '';
  [
    { label: 'Income Holdings', value: incomePositions.length + ' positions', sub: fmt(incomeVal) + ' (' + (totalVal>0?(incomeVal/totalVal*100).toFixed(1):'0') + '%)' },
    { label: 'Growth Holdings', value: growthPositions.length + ' positions', sub: fmt(growthVal) + ' (' + (totalVal>0?(growthVal/totalVal*100).toFixed(1):'0') + '%)' },
    { label: 'Income Score', value: scores.income + '/100', sub: scoreLabel(scores.income) },
    { label: 'Est. Yield', value: scores.incomeWeight > 20 ? '~2-4%' : scores.incomeWeight > 5 ? '~1-2%' : '<1%', sub: 'Based on income allocation' },
  ].forEach(c => {
    const d = document.createElement('div');
    d.className = 'summary-card';
    d.innerHTML = '<div class="label">' + c.label + '</div><div class="value" style="font-size:16px">' + c.value + '</div><div class="sub">' + c.sub + '</div>';
    grid.appendChild(d);
  });

  // Income vs growth chart
  makeChart('income', document.getElementById('incomeChart'), {
    type: 'doughnut',
    data: { labels: ['Income-Oriented','Growth-Oriented'], datasets: [{ data: [incomeVal, growthVal], backgroundColor: ['#22c55e','#3b82f6'], borderWidth: 0 }] },
    options: { responsive: true, cutout: '60%', plugins: { legend: { position: 'bottom', labels: { padding: 10, usePointStyle: true, pointStyleWidth: 8 } } } }
  });

  // Income by account type
  const acctIncome = {};
  incomePositions.forEach(p => {
    const a = p._accountName || 'Unknown';
    acctIncome[a] = (acctIncome[a]||0) + (p.market_value||p.value||0);
  });
  const acctEntries = Object.entries(acctIncome).sort((a,b) => b[1]-a[1]);
  if (acctEntries.length > 0) {
    makeChart('incomeAccount', document.getElementById('incomeAccountChart'), {
      type: 'bar',
      data: { labels: acctEntries.map(e=>e[0]), datasets: [{ data: acctEntries.map(e=>e[1]), backgroundColor: '#22c55e', borderRadius: 4 }] },
      options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { grid: { color: 'rgba(42,53,80,0.3)' }, ticks: { callback: v => '$' + (v/1000).toFixed(0) + 'k' } }, x: { grid: { display: false } } } }
    });
  }

  // Income holdings list
  const holdGrid = document.getElementById('incomeHoldingsGrid');
  holdGrid.innerHTML = '';
  incomePositions.sort((a,b) => (b.market_value||b.value||0) - (a.market_value||a.value||0)).forEach(pos => {
    const sym = pos.security?.symbol || pos.symbol || '--';
    const mv = pos.market_value || pos.value || 0;
    const weight = totalVal > 0 ? (mv/totalVal*100) : 0;
    const d = document.createElement('div');
    d.className = 'position-card';
    d.innerHTML = '<div class="pos-header"><div><div class="pos-symbol">' + escapeHtml(sym) + '</div><div class="pos-name">' + escapeHtml(pos.security?.name||'') + '</div></div>' +
      '<div style="text-align:right"><span style="background:var(--green-bg);color:var(--green);padding:2px 8px;border-radius:4px;font-size:10px;font-weight:600">' + escapeHtml(pos._sector) + '</span></div></div>' +
      '<div class="pos-values"><div class="pos-metric"><div class="pm-label">Value</div><div class="pm-value">' + fmt(mv) + '</div></div>' +
      '<div class="pos-metric"><div class="pm-label">Weight</div><div class="pm-value">' + weight.toFixed(1) + '%</div></div></div>' +
      '<div class="pos-weight-bar"><div class="pos-weight-fill" style="width:' + Math.min(100,weight) + '%;background:var(--green)"></div></div>';
    holdGrid.appendChild(d);
  });
  if (incomePositions.length === 0) {
    holdGrid.innerHTML = '<div class="position-card" style="text-align:center;padding:40px;color:var(--text-muted)">No income-oriented positions detected. Consider adding dividend ETFs, REITs, or bond funds.</div>';
  }
}

// ─── Tax Tab ─────────────────────────────────────────────────────────────────
function renderTax() {
  const scores = computeScores();
  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);

  // Tax score ring
  const circ = 2 * Math.PI * 42;
  const taxRing = document.getElementById('taxRingFill');
  taxRing.style.strokeDasharray = circ;
  taxRing.style.strokeDashoffset = circ * (1 - scores.taxEfficiency / 100);
  taxRing.style.stroke = scoreColor(scores.taxEfficiency);
  document.getElementById('taxScoreText').textContent = scores.taxEfficiency;
  document.getElementById('taxSummary').textContent = scores.taxDetail;

  // Summary cards: gains/losses by account type
  const acctTypes = { 'RRSP': { gains: 0, losses: 0, value: 0 }, 'TFSA': { gains: 0, losses: 0, value: 0 }, 'Non-Registered': { gains: 0, losses: 0, value: 0 } };
  filteredPositions.forEach(p => {
    const name = p._accountName || '';
    const type = /rrsp|lira|rrif/i.test(name) ? 'RRSP' : /tfsa/i.test(name) ? 'TFSA' : 'Non-Registered';
    const gl = (p.market_value || p.value || 0) - (p.book_value || (p.market_value || p.value || 0));
    acctTypes[type].value += (p.market_value || p.value || 0);
    if (gl >= 0) acctTypes[type].gains += gl;
    else acctTypes[type].losses += gl;
  });

  const sumGrid = document.getElementById('taxSummaryGrid');
  sumGrid.innerHTML = '';
  Object.entries(acctTypes).forEach(([type, data]) => {
    if (data.value === 0 && data.gains === 0 && data.losses === 0) return;
    const d = document.createElement('div');
    d.className = 'summary-card';
    d.innerHTML = '<div class="label">' + type + '</div><div class="value" style="font-size:16px">' + fmt(data.value) + '</div>' +
      '<div class="sub"><span class="positive">' + fmt(data.gains) + ' gains</span> · <span class="negative">' + fmt(data.losses) + ' losses</span></div>';
    sumGrid.appendChild(d);
  });

  // Gains/losses bar chart by account
  const acctGL = {};
  filteredPositions.forEach(p => {
    const a = p._accountName || 'Unknown';
    if (!acctGL[a]) acctGL[a] = { gains: 0, losses: 0 };
    const gl = (p.market_value || p.value || 0) - (p.book_value || (p.market_value || p.value || 0));
    if (gl >= 0) acctGL[a].gains += gl;
    else acctGL[a].losses += gl;
  });
  const glEntries = Object.entries(acctGL).sort((a,b) => (b[1].gains + b[1].losses) - (a[1].gains + a[1].losses));
  makeChart('taxGL', document.getElementById('taxGLChart'), {
    type: 'bar',
    data: {
      labels: glEntries.map(e => e[0]),
      datasets: [
        { label: 'Unrealized Gains', data: glEntries.map(e => e[1].gains), backgroundColor: '#22c55e', borderRadius: 4 },
        { label: 'Unrealized Losses', data: glEntries.map(e => e[1].losses), backgroundColor: '#ef4444', borderRadius: 4 },
      ]
    },
    options: { responsive: true, plugins: { legend: { position: 'bottom', labels: { usePointStyle: true, pointStyleWidth: 8 } } }, scales: { y: { grid: { color: 'rgba(42,53,80,0.3)' }, ticks: { callback: v => '$' + (v/1000).toFixed(1) + 'k' } }, x: { grid: { display: false } } } }
  });

  // Tax issues list
  const issueDiv = document.getElementById('taxIssues');
  issueDiv.innerHTML = '';
  if (scores.taxIssues.length > 0) {
    scores.taxIssues.forEach(issue => {
      const d = document.createElement('div');
      d.className = 'risk-factor';
      d.innerHTML = '<div class="severity medium"></div><div><div class="rf-title">Tax Optimization Opportunity</div><div class="rf-desc">' + escapeHtml(issue) + '</div></div>';
      issueDiv.appendChild(d);
    });
  } else {
    const d = document.createElement('div');
    d.className = 'risk-factor';
    d.innerHTML = '<div class="severity low"></div><div><div class="rf-title">No Tax Issues Detected</div><div class="rf-desc">Holdings appear well-placed across account types for tax efficiency.</div></div>';
    issueDiv.appendChild(d);
  }

  // Harvestable losses in non-reg
  const harvestable = filteredPositions.filter(p => {
    const name = p._accountName || '';
    const isNonReg = !/rrsp|lira|rrif|tfsa/i.test(name);
    const gl = (p.market_value || p.value || 0) - (p.book_value || 0);
    return isNonReg && gl < -100;
  }).sort((a,b) => ((a.market_value||a.value||0) - (a.book_value||0)) - ((b.market_value||b.value||0) - (b.book_value||0)));

  if (harvestable.length > 0) {
    const section = document.createElement('div');
    section.style.marginTop = '20px';
    section.innerHTML = '<h3 style="font-size:14px;font-weight:600;margin-bottom:12px;color:var(--green)">Tax-Loss Harvesting Candidates</h3>';
    harvestable.forEach(p => {
      const sym = p.security?.symbol || p.symbol || '--';
      const gl = (p.market_value || p.value || 0) - (p.book_value || 0);
      const d = document.createElement('div');
      d.className = 'risk-factor';
      d.innerHTML = '<div class="severity high"></div><div><div class="rf-title">' + escapeHtml(sym) + ' — ' + fmt(gl) + ' unrealized loss</div><div class="rf-desc">In non-registered account. Sell to crystallize loss (potential tax savings ~' + fmt(Math.abs(gl) * 0.25) + '). Wait 30 days before re-buying to avoid superficial loss rules.</div></div>';
      section.appendChild(d);
    });
    issueDiv.appendChild(section);
  }
}

// ─── Small & Big Moves Generator ─────────────────────────────────────────────
function generateMoves() {
  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  if (!totalVal || filteredPositions.length === 0) return;
  const scores = computeScores();
  const smallMoves = [], bigMoves = [];

  // Analyze positions
  const sorted = [...filteredPositions].sort((a,b) => (b.market_value||b.value||0) - (a.market_value||a.value||0));
  const weights = sorted.map(p => ({ sym: p.security?.symbol||p.symbol||'?', w: (p.market_value||p.value||0)/totalVal*100, mv: p.market_value||p.value||0, bv: p.book_value||0, name: p.security?.name||'' }));

  // Small moves based on risk tolerance
  const maxAcceptable = riskTolerance <= 3 ? 10 : riskTolerance <= 5 ? 15 : riskTolerance <= 7 ? 25 : 35;
  weights.forEach(w => {
    if (w.w > maxAcceptable) {
      const trimAmt = w.mv * (1 - maxAcceptable / w.w);
      smallMoves.push({ title: 'Trim ' + w.sym, desc: 'Currently ' + w.w.toFixed(1) + '% of portfolio (max ' + maxAcceptable + '% for your risk level). Trim ~' + fmt(trimAmt) + '.', impact: 'Reduces concentration risk', color: 'var(--yellow)' });
    }
  });

  // Losses for tax-loss harvesting
  const losses = sorted.filter(p => (p.book_value||0) > (p.market_value||p.value||0)).map(p => ({ sym: p.security?.symbol||p.symbol, loss: (p.market_value||p.value||0) - p.book_value, acct: p._accountName||'' }));
  losses.filter(l => !l.acct.includes('TFSA') && !l.acct.includes('RRSP')).forEach(l => {
    smallMoves.push({ title: 'Tax-loss harvest ' + l.sym, desc: 'Unrealized loss of ' + fmt(l.loss) + ' in taxable account. Sell and re-buy similar ETF after 30 days.', impact: 'Potential tax savings of ' + fmt(Math.abs(l.loss) * 0.25), color: 'var(--green)' });
  });

  // Big moves
  const regionMap = {};
  filteredPositions.forEach(p => {
    const r = inferRegion(p);
    regionMap[r] = (regionMap[r]||0) + (p.market_value||p.value||0);
  });
  Object.entries(regionMap).forEach(([r, v]) => {
    const pctVal = v/totalVal*100;
    if (r === 'Canada' && pctVal > 50) bigMoves.push({ title: 'Reduce Canadian home bias', desc: 'Canada is ' + pctVal.toFixed(1) + '% of your portfolio but represents <4% of global market cap. Add international diversification.', impact: 'Better global diversification' });
    if (r === 'United States' && pctVal > 70) bigMoves.push({ title: 'Add international exposure', desc: 'US-heavy at ' + pctVal.toFixed(1) + '%. Consider emerging markets or developed international ETFs.', impact: 'Broader geographic coverage' });
  });

  if (filteredPositions.length < 8 && riskTolerance <= 5) bigMoves.push({ title: 'Increase diversification', desc: 'Only ' + filteredPositions.length + ' positions. Consider all-in-one ETFs like XEQT or VGRO for instant diversification.', impact: 'Reduces single-stock risk significantly' });

  const sectorMap = {};
  filteredPositions.forEach(p => { const s = inferAssetClass(p); sectorMap[s] = (sectorMap[s]||0) + (p.market_value||p.value||0); });
  const hasBonds = sectorMap['Fixed Income'] || 0;
  if (riskTolerance <= 4 && hasBonds/totalVal < 0.1) bigMoves.push({ title: 'Add fixed income allocation', desc: 'Conservative risk profile but less than 10% in bonds. Consider bond ETFs like XBB.TO or ZAG.TO.', impact: 'Reduces portfolio volatility' });
  if (riskTolerance >= 7 && hasBonds/totalVal > 0.3) bigMoves.push({ title: 'Reduce bond allocation', desc: 'Aggressive risk profile but ' + ((hasBonds/totalVal)*100).toFixed(0) + '% in bonds. May be limiting growth potential.', impact: 'Higher expected returns' });

  if (smallMoves.length === 0) smallMoves.push({ title: 'Portfolio looks well-tuned', desc: 'No immediate small adjustments needed at your current risk level.', impact: 'Keep monitoring', color: 'var(--green)' });
  if (bigMoves.length === 0) bigMoves.push({ title: 'No major restructuring needed', desc: 'Your portfolio structure aligns well with your risk tolerance.', impact: 'Stay the course', color: 'var(--green)' });

  renderMoves('smallMoves', 'smallMovesSection', smallMoves, 'small');
  renderMoves('bigMoves', 'bigMovesSection', bigMoves, 'big');
}

function renderMoves(containerId, sectionId, moves, type) {
  document.getElementById(sectionId).style.display = 'block';
  const container = document.getElementById(containerId);
  container.innerHTML = '';
  moves.forEach(m => {
    const d = document.createElement('div');
    d.className = 'action-card';
    d.innerHTML = '<div class="action-icon ' + type + '">' + (type === 'small' ? 'S' : 'B') + '</div><div><div class="action-title">' + escapeHtml(m.title) + '</div><div class="action-desc">' + escapeHtml(m.desc) + '</div><div class="action-impact" style="color:' + (m.color || (type==='small'?'var(--green)':'var(--purple)')) + '">' + escapeHtml(m.impact) + '</div></div>';
    container.appendChild(d);
  });
}

// ─── AI Position Ratings ─────────────────────────────────────────────────────
async function ratePositions() {
  if (!apiKey) { showToast('Set your API key first', 'error'); toggleSettings(); return; }
  if (filteredPositions.length === 0) { showToast('No positions to rate', 'error'); return; }

  const btn = document.getElementById('btnRatePositions');
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner"></span> Rating positions...';

  const totalVal = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const positionList = filteredPositions.map(p => {
    const mv = p.market_value || p.value || 0;
    const bv = p.book_value || mv;
    return {
      symbol: p.security?.symbol || p.symbol || 'N/A',
      name: p.security?.name || '',
      market_value: Math.round(mv*100)/100,
      book_value: Math.round(bv*100)/100,
      weight_pct: totalVal > 0 ? Math.round(mv/totalVal*10000)/100 : 0,
      return_pct: bv > 0 ? Math.round((mv-bv)/bv*10000)/100 : 0,
      account: p._accountName || 'Unknown',
      type: p.security?.type || '',
      currency: p.security?.currency || p.currency || 'CAD',
    };
  });

  const riskLabel = riskTolerance <= 3 ? 'conservative' : riskTolerance <= 5 ? 'moderate' : riskTolerance <= 7 ? 'growth' : 'aggressive';

  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey, 'anthropic-version': '2023-06-01', 'anthropic-dangerous-direct-browser-access': 'true' },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 4096,
        system: 'You are a senior portfolio analyst rating positions for a Canadian investor with a ' + riskLabel + ' risk profile (risk tolerance ' + riskTolerance + '/10). Rate each position 1-10 based on quality, portfolio fit, sizing, and suitability for their risk profile. Respond with ONLY valid JSON, no markdown, no explanation outside JSON.',
        messages: [{ role: 'user', content: 'Rate each position:\n\n' + JSON.stringify(positionList, null, 2) + '\n\nRespond with ONLY this JSON format:\n{"positions":[{"symbol":"...","score":8,"recommendation":"Hold","reasoning":"one sentence"}],"portfolio_score":72,"summary":"2-3 sentence assessment"}\n\nRecommendation must be: "Strong Buy", "Buy", "Hold", "Trim", or "Sell".\nScores: 1-3=Poor, 4-5=Below Avg, 6-7=Good, 8-9=Very Good, 10=Excellent.' }],
      }),
    });

    if (!response.ok) { const err = await response.json().catch(()=>({})); throw new Error(err.error?.message || 'API error: ' + response.status); }
    const data = await response.json();
    const text = data.content?.[0]?.text || '';

    try {
      const parsed = JSON.parse(text.replace(/```json\n?/g,'').replace(/```/g,'').trim());
      if (parsed.positions) {
        parsed.positions.forEach(p => { positionRatings[p.symbol] = p; });
        if (parsed.portfolio_score) {
          const scores = computeScores();
          document.getElementById('healthScoreText').textContent = parsed.portfolio_score;
          const circ = 2 * Math.PI * 42;
          const ring = document.getElementById('healthRingFill');
          ring.style.strokeDashoffset = circ * (1 - parsed.portfolio_score / 100);
          ring.style.stroke = scoreColor(parsed.portfolio_score);
        }
        if (parsed.summary) document.getElementById('healthSummary').textContent = parsed.summary;
        renderHoldingsTab();
        showToast('Rated ' + parsed.positions.length + ' positions', 'success');
      }
    } catch(parseErr) {
      console.error('Failed to parse AI ratings:', parseErr, text);
      showToast('AI returned invalid format. Try again.', 'error');
    }
  } catch(err) {
    console.error('Rating error:', err);
    showToast('Rating failed: ' + err.message, 'error');
  }

  btn.disabled = false;
  btn.innerHTML = 'Get AI Position Ratings';
}

// ─── AI Analysis ─────────────────────────────────────────────────────────────
async function runAnalysis() {
  if (!apiKey) { showToast('Set your API key first', 'error'); toggleSettings(); return; }
  if (filteredPositions.length === 0) { showToast('No portfolio data', 'error'); return; }

  const btn = document.getElementById('btnAnalyze');
  const responseEl = document.getElementById('aiResponse');
  const promptType = document.getElementById('promptSelect').value;

  btn.disabled = true;
  btn.innerHTML = '<span class="spinner"></span> Analyzing...';
  responseEl.classList.add('loading');
  responseEl.innerHTML = '<div class="ai-content streaming-cursor"></div>';

  const portfolioSummary = buildPortfolioSummary();
  let systemPrompt = PROMPTS[promptType];
  if (promptType === 'custom') {
    const customQ = document.getElementById('customPrompt').value.trim();
    if (!customQ) { showToast('Enter a question', 'error'); resetAnalyzeBtn(); return; }
    systemPrompt = 'You are a senior portfolio analyst helping a Canadian investor. Answer their specific question. Be specific with numbers, percentages, and actionable advice. Use CAD. Format with markdown.';
    portfolioSummary.customQuestion = customQ;
  }

  const riskLabel = riskTolerance <= 3 ? 'conservative' : riskTolerance <= 5 ? 'moderate' : riskTolerance <= 7 ? 'growth' : 'aggressive';
  systemPrompt += '\n\nThe investor has a ' + riskLabel + ' risk profile (tolerance: ' + riskTolerance + '/10). Tailor your advice accordingly.';

  const userMessage = promptType === 'custom'
    ? 'Portfolio:\n\n' + JSON.stringify(portfolioSummary, null, 2) + '\n\nQuestion: ' + portfolioSummary.customQuestion
    : 'Portfolio:\n\n' + JSON.stringify(portfolioSummary, null, 2) + '\n\nAnalyze this portfolio.';

  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey, 'anthropic-version': '2023-06-01', 'anthropic-dangerous-direct-browser-access': 'true' },
      body: JSON.stringify({ model: 'claude-sonnet-4-20250514', max_tokens: 4096, system: systemPrompt, messages: [{ role: 'user', content: userMessage }], stream: true }),
    });

    if (!response.ok) { const err = await response.json().catch(()=>({})); throw new Error(err.error?.message || 'API error: ' + response.status); }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let fullText = '', buffer = '';
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const d = line.slice(6).trim();
          if (d === '[DONE]') continue;
          try {
            const parsed = JSON.parse(d);
            if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
              fullText += parsed.delta.text;
              const el = responseEl.querySelector('.ai-content');
              if (el) { el.innerHTML = renderMarkdown(fullText); el.classList.add('streaming-cursor'); responseEl.scrollTop = responseEl.scrollHeight; }
            }
          } catch(e) {}
        }
      }
    }
    const el = responseEl.querySelector('.ai-content');
    if (el) { el.innerHTML = renderMarkdown(fullText); el.classList.remove('streaming-cursor'); }
    responseEl.classList.remove('loading');
  } catch(err) {
    console.error('Analysis error:', err);
    responseEl.innerHTML = '<div class="ai-content" style="color:var(--red)"><strong>Error:</strong> ' + escapeHtml(err.message) + '</div>';
    responseEl.classList.remove('loading');
    showToast('Analysis failed: ' + err.message, 'error');
  }
  resetAnalyzeBtn();
}

function resetAnalyzeBtn() {
  const btn = document.getElementById('btnAnalyze');
  btn.disabled = !apiKey || filteredPositions.length === 0;
  btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polygon points="5 3 19 12 5 21 5 3"/></svg> Analyze';
}

function buildPortfolioSummary() {
  const totalValue = filteredPositions.reduce((s,p) => s + (p.market_value || p.value || 0), 0);
  const totalBook = filteredPositions.reduce((s,p) => s + (p.book_value || p.market_value || p.value || 0), 0);
  const byAccount = {};
  filteredPositions.forEach(pos => {
    const acct = pos._accountName || 'Unknown';
    if (!byAccount[acct]) byAccount[acct] = [];
    byAccount[acct].push({
      symbol: pos.security?.symbol || pos.symbol || 'N/A',
      name: pos.security?.name || '',
      quantity: pos.quantity,
      book_value: pos.book_value ? Math.round(pos.book_value*100)/100 : null,
      market_value: Math.round((pos.market_value||pos.value||0)*100)/100,
      currency: pos.security?.currency || pos.currency || 'CAD',
      type: pos.security?.type || '',
    });
  });
  return {
    total_market_value_cad: Math.round(totalValue*100)/100,
    total_book_value_cad: Math.round(totalBook*100)/100,
    unrealized_gain_loss: Math.round((totalValue-totalBook)*100)/100,
    number_of_accounts: [...new Set(filteredPositions.map(p => p._accountName))].length,
    number_of_positions: filteredPositions.length,
    accounts: byAccount,
  };
}

// ─── Markdown Renderer (improved) ───────────────────────────────────────────
function renderMarkdown(text) {
  let html = escapeHtml(text);
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
  html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
  html = html.replace(/^---$/gm, '<hr>');
  html = html.replace(/^[\-\*] (.+)$/gm, '<ul-li>$1</ul-li>');
  html = html.replace(/^\d+\. (.+)$/gm, '<ol-li>$1</ol-li>');
  html = html.replace(/(<ul-li>[\s\S]*?<\/ul-li>)/g, function(match) { return '<ul>' + match + '</ul>'; });
  html = html.replace(/<\/ul>\s*<ul>/g, '');
  html = html.replace(/<ul-li>/g, '<li>').replace(/<\/ul-li>/g, '</li>');
  html = html.replace(/(<ol-li>[\s\S]*?<\/ol-li>)/g, function(match) { return '<ol>' + match + '</ol>'; });
  html = html.replace(/<\/ol>\s*<ol>/g, '');
  html = html.replace(/<ol-li>/g, '<li>').replace(/<\/ol-li>/g, '</li>');
  html = html.replace(/\n\n/g, '</p><p>');
  html = '<p>' + html + '</p>';
  html = html.replace(/\n/g, '<br>');
  html = html.replace(/<p>\s*<\/p>/g, '');
  html = html.replace(/<p>\s*(<h[123]>)/g, '$1');
  html = html.replace(/(<\/h[123]>)\s*<\/p>/g, '$1');
  html = html.replace(/<p>\s*(<ul>)/g, '$1');
  html = html.replace(/(<\/ul>)\s*<\/p>/g, '$1');
  html = html.replace(/<p>\s*(<ol>)/g, '$1');
  html = html.replace(/(<\/ol>)\s*<\/p>/g, '$1');
  html = html.replace(/<p>\s*(<hr>)/g, '$1');
  html = html.replace(/(<hr>)\s*<\/p>/g, '$1');
  return html;
}

// ─── Settings ────────────────────────────────────────────────────────────────
function toggleSettings() {
  const panel = document.getElementById('settingsPanel');
  panel.classList.toggle('visible');
  if (panel.classList.contains('visible')) document.getElementById('apiKeyInput').focus();
}

function saveApiKey() {
  const key = document.getElementById('apiKeyInput').value.trim();
  if (!key) { showToast('Enter an API key', 'error'); return; }
  apiKey = key;
  if (addon) {
    addon.saveData({ apiKey: key }).then(() => { showToast('API key saved', 'success'); updateStatus('connected', 'API key saved'); }).catch(err => { showToast('Key set for session', 'error'); });
  } else { showToast('API key set for session', 'success'); updateStatus('connected', 'API key set'); }
  document.getElementById('settingsPanel').classList.remove('visible');
  document.getElementById('btnAnalyze').disabled = filteredPositions.length === 0;
}

function onPromptChange() {
  const val = document.getElementById('promptSelect').value;
  document.getElementById('customPromptArea').classList.toggle('visible', val === 'custom');
  if (val === 'custom') document.getElementById('customPrompt').focus();
}

// ─── Utilities ───────────────────────────────────────────────────────────────
function updateStatus(status, title) {
  const dot = document.getElementById('statusDot');
  dot.className = 'status-dot ' + status;
  dot.title = title || status;
}

function showToast(msg, type) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.className = 'toast ' + (type||'') + ' visible';
  setTimeout(() => t.classList.remove('visible'), 3000);
}

// ─── Demo Data ───────────────────────────────────────────────────────────────
function loadDemoData() {
  portfolioData = {
    positions: [
      // TFSA — Growth + US Equity
      { class: 'equity', category: 'US Stocks', security: { symbol: 'VFV.TO', name: 'Vanguard S&P 500 Index ETF', currency: 'CAD', type: 'etf' }, quantity: 500, book_value: 42500, market_value: 55200, _accountName: 'TFSA - Questrade' },
      { class: 'equity', category: 'US Stocks', security: { symbol: 'XQQ.TO', name: 'iShares NASDAQ 100 Index ETF', currency: 'CAD', type: 'etf' }, quantity: 200, book_value: 18000, market_value: 24800, _accountName: 'TFSA - Questrade' },
      { class: 'crypto', category: 'Crypto', security: { symbol: 'BTC', name: 'Bitcoin', currency: 'USD', type: 'crypto' }, quantity: 0.75, book_value: 28000, market_value: 48500, _accountName: 'Shakepay' },
      // RRSP — Diversified + US dividend payers + Intl
      { class: 'equity', category: 'Global Stocks', security: { symbol: 'XEQT.TO', name: 'iShares Core Equity ETF Portfolio', currency: 'CAD', type: 'etf' }, quantity: 800, book_value: 20000, market_value: 22400, _accountName: 'RRSP - RBC DI' },
      { class: 'equity', category: 'Canadian Stocks', security: { symbol: 'TD.TO', name: 'Toronto-Dominion Bank', currency: 'CAD', type: 'equity' }, quantity: 150, book_value: 12750, market_value: 12300, _accountName: 'RRSP - RBC DI' },
      { class: 'equity', category: 'International Stocks', security: { symbol: 'XEF.TO', name: 'iShares Core MSCI EAFE IMI Index ETF', currency: 'CAD', type: 'etf' }, quantity: 300, book_value: 9600, market_value: 10500, _accountName: 'RRSP - RBC DI' },
      { class: 'fixed-income', category: 'Canadian Bonds', security: { symbol: 'ZAG.TO', name: 'BMO Aggregate Bond Index ETF', currency: 'CAD', type: 'etf' }, quantity: 400, book_value: 5800, market_value: 5600, _accountName: 'RRSP - RBC DI' },
      // Non-Reg — Dividend / Income / Tax-loss candidates
      { class: 'equity', category: 'Canadian Stocks', security: { symbol: 'ENB.TO', name: 'Enbridge Inc', currency: 'CAD', type: 'equity' }, quantity: 200, book_value: 9800, market_value: 11200, _accountName: 'Non-Reg - Questrade' },
      { class: 'equity', category: 'Canadian Stocks', security: { symbol: 'RY.TO', name: 'Royal Bank of Canada', currency: 'CAD', type: 'equity' }, quantity: 60, book_value: 8100, market_value: 9300, _accountName: 'Non-Reg - Questrade' },
      { class: 'equity', category: 'Canadian Stocks', security: { symbol: 'FTS.TO', name: 'Fortis Inc', currency: 'CAD', type: 'equity' }, quantity: 100, book_value: 5600, market_value: 5900, _accountName: 'Non-Reg - Questrade' },
      { class: 'equity', category: 'Canadian REITs', security: { symbol: 'XRE.TO', name: 'iShares S&P/TSX Capped REIT Index ETF', currency: 'CAD', type: 'etf' }, quantity: 250, book_value: 4200, market_value: 3800, _accountName: 'Non-Reg - Questrade' },
      { class: 'equity', category: 'Canadian Stocks', security: { symbol: 'NTR.TO', name: 'Nutrien Ltd', currency: 'CAD', type: 'equity' }, quantity: 50, book_value: 4500, market_value: 3200, _accountName: 'Non-Reg - Questrade' },
      { class: 'equity', category: 'Canadian Stocks', security: { symbol: 'SHOP.TO', name: 'Shopify Inc', currency: 'CAD', type: 'equity' }, quantity: 25, book_value: 2800, market_value: 2500, _accountName: 'TFSA - Questrade' },
    ],
    institutions: [
      { _id: '1', name: 'Questrade' },
      { _id: '2', name: 'RBC Direct Investing' },
      { _id: '3', name: 'Shakepay' },
    ],
    totalValue: 0, totalBook: 0,
  };
  let tv = 0, tb = 0;
  portfolioData.positions.forEach(p => { tv += p.market_value || 0; tb += p.book_value || 0; });
  portfolioData.totalValue = tv;
  portfolioData.totalBook = tb;
  filteredPositions = [...portfolioData.positions];
  populateAccountFilter();
  renderAllTabs();
  document.getElementById('btnAnalyze').disabled = !apiKey;
}

// ─── Event Listeners ─────────────────────────────────────────────────────────
document.getElementById('apiKeyInput').addEventListener('keydown', function(e) { if (e.key === 'Enter') saveApiKey(); });
document.getElementById('customPrompt').addEventListener('keydown', function(e) { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') runAnalysis(); });
</script>
</body>
</html>
